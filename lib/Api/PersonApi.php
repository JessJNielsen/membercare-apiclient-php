<?php
/**
 * PersonApi
 * PHP version 5
 *
 * @category Class
 * @package  Membercare\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Membercare API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * Contact: support@membercare.dk
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.62
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Membercare\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Membercare\Client\ApiException;
use Membercare\Client\Configuration;
use Membercare\Client\HeaderSelector;
use Membercare\Client\ObjectSerializer;

/**
 * PersonApi Class Doc Comment
 *
 * @category Class
 * @package  Membercare\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PersonApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV1PersonsDebtorAccountNumberFamilyPut
     *
     * Updates a given familyRelation.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.FamilyRelationId
- FamilyRelation.StartDate
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\FamilyRelation
     */
    public function apiV1PersonsDebtorAccountNumberFamilyPut($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->apiV1PersonsDebtorAccountNumberFamilyPutWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation apiV1PersonsDebtorAccountNumberFamilyPutWithHttpInfo
     *
     * Updates a given familyRelation.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.FamilyRelationId
- FamilyRelation.StartDate
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\FamilyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV1PersonsDebtorAccountNumberFamilyPutWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->apiV1PersonsDebtorAccountNumberFamilyPutRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\FamilyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV1PersonsDebtorAccountNumberFamilyPutAsync
     *
     * Updates a given familyRelation.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.FamilyRelationId
- FamilyRelation.StartDate
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1PersonsDebtorAccountNumberFamilyPutAsync($token, $debtor_account_number, $body = null)
    {
        return $this->apiV1PersonsDebtorAccountNumberFamilyPutAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV1PersonsDebtorAccountNumberFamilyPutAsyncWithHttpInfo
     *
     * Updates a given familyRelation.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.FamilyRelationId
- FamilyRelation.StartDate
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV1PersonsDebtorAccountNumberFamilyPutAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->apiV1PersonsDebtorAccountNumberFamilyPutRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV1PersonsDebtorAccountNumberFamilyPut'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.FamilyRelationId
- FamilyRelation.StartDate
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV1PersonsDebtorAccountNumberFamilyPutRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling apiV1PersonsDebtorAccountNumberFamilyPut'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling apiV1PersonsDebtorAccountNumberFamilyPut'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/family';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeDebtorAccountNumberOnPerson
     *
     * Change DebtorAccountNumber for a Person
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $new_debtor_account_number new_debtor_account_number (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function changeDebtorAccountNumberOnPerson($debtor_account_number, $token, $new_debtor_account_number = null)
    {
        list($response) = $this->changeDebtorAccountNumberOnPersonWithHttpInfo($debtor_account_number, $token, $new_debtor_account_number);
        return $response;
    }

    /**
     * Operation changeDebtorAccountNumberOnPersonWithHttpInfo
     *
     * Change DebtorAccountNumber for a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $new_debtor_account_number (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeDebtorAccountNumberOnPersonWithHttpInfo($debtor_account_number, $token, $new_debtor_account_number = null)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->changeDebtorAccountNumberOnPersonRequest($debtor_account_number, $token, $new_debtor_account_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation changeDebtorAccountNumberOnPersonAsync
     *
     * Change DebtorAccountNumber for a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $new_debtor_account_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDebtorAccountNumberOnPersonAsync($debtor_account_number, $token, $new_debtor_account_number = null)
    {
        return $this->changeDebtorAccountNumberOnPersonAsyncWithHttpInfo($debtor_account_number, $token, $new_debtor_account_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeDebtorAccountNumberOnPersonAsyncWithHttpInfo
     *
     * Change DebtorAccountNumber for a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $new_debtor_account_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDebtorAccountNumberOnPersonAsyncWithHttpInfo($debtor_account_number, $token, $new_debtor_account_number = null)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->changeDebtorAccountNumberOnPersonRequest($debtor_account_number, $token, $new_debtor_account_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeDebtorAccountNumberOnPerson'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $new_debtor_account_number (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function changeDebtorAccountNumberOnPersonRequest($debtor_account_number, $token, $new_debtor_account_number = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling changeDebtorAccountNumberOnPerson'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling changeDebtorAccountNumberOnPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/changeDebtorAccountNumber';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($new_debtor_account_number !== null) {
            $queryParams['newDebtorAccountNumber'] = ObjectSerializer::toQueryValue($new_debtor_account_number, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInterestForPerson
     *
     * Ends the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInterestForPerson($token, $debtor_account_number, $body = null)
    {
        $this->deleteInterestForPersonWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation deleteInterestForPersonWithHttpInfo
     *
     * Ends the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInterestForPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->deleteInterestForPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInterestForPersonAsync
     *
     * Ends the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInterestForPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->deleteInterestForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInterestForPersonAsyncWithHttpInfo
     *
     * Ends the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInterestForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->deleteInterestForPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInterestForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInterestForPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling deleteInterestForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling deleteInterestForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/interests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePersonDocument
     *
     * Deletes a PersonDocument by document identitifcation
     *
     * @param  string $identification identification (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePersonDocument($identification, $token)
    {
        $this->deletePersonDocumentWithHttpInfo($identification, $token);
    }

    /**
     * Operation deletePersonDocumentWithHttpInfo
     *
     * Deletes a PersonDocument by document identitifcation
     *
     * @param  string $identification (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePersonDocumentWithHttpInfo($identification, $token)
    {
        $returnType = '';
        $request = $this->deletePersonDocumentRequest($identification, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePersonDocumentAsync
     *
     * Deletes a PersonDocument by document identitifcation
     *
     * @param  string $identification (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonDocumentAsync($identification, $token)
    {
        return $this->deletePersonDocumentAsyncWithHttpInfo($identification, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePersonDocumentAsyncWithHttpInfo
     *
     * Deletes a PersonDocument by document identitifcation
     *
     * @param  string $identification (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonDocumentAsyncWithHttpInfo($identification, $token)
    {
        $returnType = '';
        $request = $this->deletePersonDocumentRequest($identification, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePersonDocument'
     *
     * @param  string $identification (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePersonDocumentRequest($identification, $token)
    {
        // verify the required parameter 'identification' is set
        if ($identification === null || (is_array($identification) && count($identification) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identification when calling deletePersonDocument'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling deletePersonDocument'
            );
        }

        $resourcePath = '/api/v1/persons/document/{identification}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($identification !== null) {
            $resourcePath = str_replace(
                '{' . 'identification' . '}',
                ObjectSerializer::toPathValue($identification),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePersonFoerignSystem
     *
     * Disassociate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  int $id id (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePersonFoerignSystem($debtor_account_number, $id, $token)
    {
        $this->deletePersonFoerignSystemWithHttpInfo($debtor_account_number, $id, $token);
    }

    /**
     * Operation deletePersonFoerignSystemWithHttpInfo
     *
     * Disassociate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePersonFoerignSystemWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '';
        $request = $this->deletePersonFoerignSystemRequest($debtor_account_number, $id, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePersonFoerignSystemAsync
     *
     * Disassociate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonFoerignSystemAsync($debtor_account_number, $id, $token)
    {
        return $this->deletePersonFoerignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePersonFoerignSystemAsyncWithHttpInfo
     *
     * Disassociate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonFoerignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '';
        $request = $this->deletePersonFoerignSystemRequest($debtor_account_number, $id, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePersonFoerignSystem'
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePersonFoerignSystemRequest($debtor_account_number, $id, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling deletePersonFoerignSystem'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deletePersonFoerignSystem'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling deletePersonFoerignSystem'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/foreignSystem/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePersonProfilePicture
     *
     * Deletes a person profile picture
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePersonProfilePicture($debtor_account_number, $token)
    {
        $this->deletePersonProfilePictureWithHttpInfo($debtor_account_number, $token);
    }

    /**
     * Operation deletePersonProfilePictureWithHttpInfo
     *
     * Deletes a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePersonProfilePictureWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '';
        $request = $this->deletePersonProfilePictureRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePersonProfilePictureAsync
     *
     * Deletes a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonProfilePictureAsync($debtor_account_number, $token)
    {
        return $this->deletePersonProfilePictureAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePersonProfilePictureAsyncWithHttpInfo
     *
     * Deletes a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePersonProfilePictureAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '';
        $request = $this->deletePersonProfilePictureRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePersonProfilePicture'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePersonProfilePictureRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling deletePersonProfilePicture'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling deletePersonProfilePicture'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/profilePicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deprecatedPasswordValidation
     *
     * WARNING!!! Not possible to use with complex passwords, due to URL rules!  - Please use api/v1/password/validator?password=XXX
     *
     * @param  string $password password (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PasswordValidationError[]
     */
    public function deprecatedPasswordValidation($password, $token)
    {
        list($response) = $this->deprecatedPasswordValidationWithHttpInfo($password, $token);
        return $response;
    }

    /**
     * Operation deprecatedPasswordValidationWithHttpInfo
     *
     * WARNING!!! Not possible to use with complex passwords, due to URL rules!  - Please use api/v1/password/validator?password=XXX
     *
     * @param  string $password (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PasswordValidationError[], HTTP status code, HTTP response headers (array of strings)
     */
    public function deprecatedPasswordValidationWithHttpInfo($password, $token)
    {
        $returnType = '\Membercare\Client\Model\PasswordValidationError[]';
        $request = $this->deprecatedPasswordValidationRequest($password, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PasswordValidationError[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deprecatedPasswordValidationAsync
     *
     * WARNING!!! Not possible to use with complex passwords, due to URL rules!  - Please use api/v1/password/validator?password=XXX
     *
     * @param  string $password (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deprecatedPasswordValidationAsync($password, $token)
    {
        return $this->deprecatedPasswordValidationAsyncWithHttpInfo($password, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deprecatedPasswordValidationAsyncWithHttpInfo
     *
     * WARNING!!! Not possible to use with complex passwords, due to URL rules!  - Please use api/v1/password/validator?password=XXX
     *
     * @param  string $password (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deprecatedPasswordValidationAsyncWithHttpInfo($password, $token)
    {
        $returnType = '\Membercare\Client\Model\PasswordValidationError[]';
        $request = $this->deprecatedPasswordValidationRequest($password, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deprecatedPasswordValidation'
     *
     * @param  string $password (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deprecatedPasswordValidationRequest($password, $token)
    {
        // verify the required parameter 'password' is set
        if ($password === null || (is_array($password) && count($password) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $password when calling deprecatedPasswordValidation'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling deprecatedPasswordValidation'
            );
        }

        $resourcePath = '/api/v1/persons/password/validator/{password}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($password !== null) {
            $resourcePath = str_replace(
                '{' . 'password' . '}',
                ObjectSerializer::toPathValue($password),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation familyRelationPostApi
     *
     * Creates a child familyRelation to the person.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the parent person. (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\FamilyRelation
     */
    public function familyRelationPostApi($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->familyRelationPostApiWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation familyRelationPostApiWithHttpInfo
     *
     * Creates a child familyRelation to the person.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the parent person. (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\FamilyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function familyRelationPostApiWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->familyRelationPostApiRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\FamilyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation familyRelationPostApiAsync
     *
     * Creates a child familyRelation to the person.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the parent person. (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function familyRelationPostApiAsync($token, $debtor_account_number, $body = null)
    {
        return $this->familyRelationPostApiAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation familyRelationPostApiAsyncWithHttpInfo
     *
     * Creates a child familyRelation to the person.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the parent person. (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function familyRelationPostApiAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->familyRelationPostApiRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'familyRelationPostApi'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the parent person. (required)
     * @param  \Membercare\Client\Model\FamilyRelation $body Note that the following values Must be assigned:
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function familyRelationPostApiRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling familyRelationPostApi'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling familyRelationPostApi'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/family';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation familyRelationsApi
     *
     * Retrieves a paged result of all families containing the person with the given debtorAccountNumber.
     *
     * @param  string $debtor_account_number Id of the person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid if false only families which fulfill the following requirements will be returned:  EndDate of null, equal or higher than today and StartDate must be equal to or lower than today (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\FamilyRelationPagedResult
     */
    public function familyRelationsApi($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        list($response) = $this->familyRelationsApiWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size);
        return $response;
    }

    /**
     * Operation familyRelationsApiWithHttpInfo
     *
     * Retrieves a paged result of all families containing the person with the given debtorAccountNumber.
     *
     * @param  string $debtor_account_number Id of the person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid if false only families which fulfill the following requirements will be returned:  EndDate of null, equal or higher than today and StartDate must be equal to or lower than today (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\FamilyRelationPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function familyRelationsApiWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\FamilyRelationPagedResult';
        $request = $this->familyRelationsApiRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\FamilyRelationPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation familyRelationsApiAsync
     *
     * Retrieves a paged result of all families containing the person with the given debtorAccountNumber.
     *
     * @param  string $debtor_account_number Id of the person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid if false only families which fulfill the following requirements will be returned:  EndDate of null, equal or higher than today and StartDate must be equal to or lower than today (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function familyRelationsApiAsync($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        return $this->familyRelationsApiAsyncWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation familyRelationsApiAsyncWithHttpInfo
     *
     * Retrieves a paged result of all families containing the person with the given debtorAccountNumber.
     *
     * @param  string $debtor_account_number Id of the person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid if false only families which fulfill the following requirements will be returned:  EndDate of null, equal or higher than today and StartDate must be equal to or lower than today (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function familyRelationsApiAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\FamilyRelationPagedResult';
        $request = $this->familyRelationsApiRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'familyRelationsApi'
     *
     * @param  string $debtor_account_number Id of the person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid if false only families which fulfill the following requirements will be returned:  EndDate of null, equal or higher than today and StartDate must be equal to or lower than today (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function familyRelationsApiRequest($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling familyRelationsApi'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling familyRelationsApi'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/family';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAccessibleOrganizations
     *
     * Returns list of accessible ogranizations for the user based on the available data roles
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $web_enabled web_enabled (optional)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     * @param  bool $include_geographic_districts Will include electoral Districts in the result (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\OrganizationPagedResult
     */
    public function getAccessibleOrganizations($debtor_account_number, $token, $web_enabled = null, $page = '1', $page_size = '50', $include_geographic_districts = 'false')
    {
        list($response) = $this->getAccessibleOrganizationsWithHttpInfo($debtor_account_number, $token, $web_enabled, $page, $page_size, $include_geographic_districts);
        return $response;
    }

    /**
     * Operation getAccessibleOrganizationsWithHttpInfo
     *
     * Returns list of accessible ogranizations for the user based on the available data roles
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $web_enabled (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_geographic_districts Will include electoral Districts in the result (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\OrganizationPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAccessibleOrganizationsWithHttpInfo($debtor_account_number, $token, $web_enabled = null, $page = '1', $page_size = '50', $include_geographic_districts = 'false')
    {
        $returnType = '\Membercare\Client\Model\OrganizationPagedResult';
        $request = $this->getAccessibleOrganizationsRequest($debtor_account_number, $token, $web_enabled, $page, $page_size, $include_geographic_districts);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\OrganizationPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAccessibleOrganizationsAsync
     *
     * Returns list of accessible ogranizations for the user based on the available data roles
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $web_enabled (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_geographic_districts Will include electoral Districts in the result (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessibleOrganizationsAsync($debtor_account_number, $token, $web_enabled = null, $page = '1', $page_size = '50', $include_geographic_districts = 'false')
    {
        return $this->getAccessibleOrganizationsAsyncWithHttpInfo($debtor_account_number, $token, $web_enabled, $page, $page_size, $include_geographic_districts)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAccessibleOrganizationsAsyncWithHttpInfo
     *
     * Returns list of accessible ogranizations for the user based on the available data roles
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $web_enabled (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_geographic_districts Will include electoral Districts in the result (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAccessibleOrganizationsAsyncWithHttpInfo($debtor_account_number, $token, $web_enabled = null, $page = '1', $page_size = '50', $include_geographic_districts = 'false')
    {
        $returnType = '\Membercare\Client\Model\OrganizationPagedResult';
        $request = $this->getAccessibleOrganizationsRequest($debtor_account_number, $token, $web_enabled, $page, $page_size, $include_geographic_districts);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAccessibleOrganizations'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $web_enabled (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_geographic_districts Will include electoral Districts in the result (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAccessibleOrganizationsRequest($debtor_account_number, $token, $web_enabled = null, $page = '1', $page_size = '50', $include_geographic_districts = 'false')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getAccessibleOrganizations'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getAccessibleOrganizations'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/organizations/accessible';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($web_enabled !== null) {
            $queryParams['webEnabled'] = ObjectSerializer::toQueryValue($web_enabled, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // query params
        if ($include_geographic_districts !== null) {
            $queryParams['includeGeographicDistricts'] = ObjectSerializer::toQueryValue($include_geographic_districts, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBoardMembershipsForPerson
     *
     * Get a paged result of boardmemberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the person to get boardmemberships for. (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to include historical boardmemberships. (optional, default to true)
     * @param  bool $include_addresses Indicates wheter or not to include addresses (optional, default to false)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\BoardMembershipPagedResult
     */
    public function getBoardMembershipsForPerson($debtor_account_number, $token, $only_valid = 'true', $include_addresses = 'false', $page = '1', $page_size = '50')
    {
        list($response) = $this->getBoardMembershipsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid, $include_addresses, $page, $page_size);
        return $response;
    }

    /**
     * Operation getBoardMembershipsForPersonWithHttpInfo
     *
     * Get a paged result of boardmemberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the person to get boardmemberships for. (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to include historical boardmemberships. (optional, default to true)
     * @param  bool $include_addresses Indicates wheter or not to include addresses (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\BoardMembershipPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBoardMembershipsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $include_addresses = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\BoardMembershipPagedResult';
        $request = $this->getBoardMembershipsForPersonRequest($debtor_account_number, $token, $only_valid, $include_addresses, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\BoardMembershipPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBoardMembershipsForPersonAsync
     *
     * Get a paged result of boardmemberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the person to get boardmemberships for. (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to include historical boardmemberships. (optional, default to true)
     * @param  bool $include_addresses Indicates wheter or not to include addresses (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBoardMembershipsForPersonAsync($debtor_account_number, $token, $only_valid = 'true', $include_addresses = 'false', $page = '1', $page_size = '50')
    {
        return $this->getBoardMembershipsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid, $include_addresses, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBoardMembershipsForPersonAsyncWithHttpInfo
     *
     * Get a paged result of boardmemberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the person to get boardmemberships for. (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to include historical boardmemberships. (optional, default to true)
     * @param  bool $include_addresses Indicates wheter or not to include addresses (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBoardMembershipsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $include_addresses = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\BoardMembershipPagedResult';
        $request = $this->getBoardMembershipsForPersonRequest($debtor_account_number, $token, $only_valid, $include_addresses, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBoardMembershipsForPerson'
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the person to get boardmemberships for. (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to include historical boardmemberships. (optional, default to true)
     * @param  bool $include_addresses Indicates wheter or not to include addresses (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBoardMembershipsForPersonRequest($debtor_account_number, $token, $only_valid = 'true', $include_addresses = 'false', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getBoardMembershipsForPerson'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getBoardMembershipsForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/boardMemberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($include_addresses !== null) {
            $queryParams['includeAddresses'] = ObjectSerializer::toQueryValue($include_addresses, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCommunityGroupsByDebtorAccountNumber
     *
     * Gets community groups and their origin by debtor account number
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $valid_on valid_on (optional)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function getCommunityGroupsByDebtorAccountNumber($debtor_account_number, $token, $valid_on = null, $page = '1', $page_size = '50')
    {
        list($response) = $this->getCommunityGroupsByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token, $valid_on, $page, $page_size);
        return $response;
    }

    /**
     * Operation getCommunityGroupsByDebtorAccountNumberWithHttpInfo
     *
     * Gets community groups and their origin by debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $valid_on (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCommunityGroupsByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token, $valid_on = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getCommunityGroupsByDebtorAccountNumberRequest($debtor_account_number, $token, $valid_on, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCommunityGroupsByDebtorAccountNumberAsync
     *
     * Gets community groups and their origin by debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $valid_on (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommunityGroupsByDebtorAccountNumberAsync($debtor_account_number, $token, $valid_on = null, $page = '1', $page_size = '50')
    {
        return $this->getCommunityGroupsByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token, $valid_on, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCommunityGroupsByDebtorAccountNumberAsyncWithHttpInfo
     *
     * Gets community groups and their origin by debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $valid_on (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCommunityGroupsByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token, $valid_on = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getCommunityGroupsByDebtorAccountNumberRequest($debtor_account_number, $token, $valid_on, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCommunityGroupsByDebtorAccountNumber'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $valid_on (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCommunityGroupsByDebtorAccountNumberRequest($debtor_account_number, $token, $valid_on = null, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getCommunityGroupsByDebtorAccountNumber'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getCommunityGroupsByDebtorAccountNumber'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/CommunityGroups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($valid_on !== null) {
            $queryParams['validOn'] = ObjectSerializer::toQueryValue($valid_on, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCustomFieldValuesForPerson
     *
     * Retrieves a paged result of all CustomFieldValues for the person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number DebtorAccountNumber of a member, can be either a person or company (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\CustomFieldValuePagedResult
     */
    public function getCustomFieldValuesForPerson($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        list($response) = $this->getCustomFieldValuesForPersonWithHttpInfo($debtor_account_number, $token, $page, $page_size);
        return $response;
    }

    /**
     * Operation getCustomFieldValuesForPersonWithHttpInfo
     *
     * Retrieves a paged result of all CustomFieldValues for the person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number DebtorAccountNumber of a member, can be either a person or company (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\CustomFieldValuePagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCustomFieldValuesForPersonWithHttpInfo($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\CustomFieldValuePagedResult';
        $request = $this->getCustomFieldValuesForPersonRequest($debtor_account_number, $token, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\CustomFieldValuePagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCustomFieldValuesForPersonAsync
     *
     * Retrieves a paged result of all CustomFieldValues for the person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number DebtorAccountNumber of a member, can be either a person or company (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldValuesForPersonAsync($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        return $this->getCustomFieldValuesForPersonAsyncWithHttpInfo($debtor_account_number, $token, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCustomFieldValuesForPersonAsyncWithHttpInfo
     *
     * Retrieves a paged result of all CustomFieldValues for the person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number DebtorAccountNumber of a member, can be either a person or company (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCustomFieldValuesForPersonAsyncWithHttpInfo($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\CustomFieldValuePagedResult';
        $request = $this->getCustomFieldValuesForPersonRequest($debtor_account_number, $token, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCustomFieldValuesForPerson'
     *
     * @param  string $debtor_account_number DebtorAccountNumber of a member, can be either a person or company (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of invoices to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCustomFieldValuesForPersonRequest($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getCustomFieldValuesForPerson'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getCustomFieldValuesForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/customFields/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExternalLoginsByDebtorAccountNumber
     *
     * Gets all external logins the user is currently associated to
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\ExternalLogin[]
     */
    public function getExternalLoginsByDebtorAccountNumber($debtor_account_number, $token)
    {
        list($response) = $this->getExternalLoginsByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token);
        return $response;
    }

    /**
     * Operation getExternalLoginsByDebtorAccountNumberWithHttpInfo
     *
     * Gets all external logins the user is currently associated to
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\ExternalLogin[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getExternalLoginsByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\ExternalLogin[]';
        $request = $this->getExternalLoginsByDebtorAccountNumberRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ExternalLogin[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getExternalLoginsByDebtorAccountNumberAsync
     *
     * Gets all external logins the user is currently associated to
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExternalLoginsByDebtorAccountNumberAsync($debtor_account_number, $token)
    {
        return $this->getExternalLoginsByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExternalLoginsByDebtorAccountNumberAsyncWithHttpInfo
     *
     * Gets all external logins the user is currently associated to
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExternalLoginsByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\ExternalLogin[]';
        $request = $this->getExternalLoginsByDebtorAccountNumberRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExternalLoginsByDebtorAccountNumber'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getExternalLoginsByDebtorAccountNumberRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getExternalLoginsByDebtorAccountNumber'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getExternalLoginsByDebtorAccountNumber'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/externalLogins';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInterestsForPerson
     *
     * Get the persons interests
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Default true (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of interests to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\InterestPagedResult
     */
    public function getInterestsForPerson($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        list($response) = $this->getInterestsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size);
        return $response;
    }

    /**
     * Operation getInterestsForPersonWithHttpInfo
     *
     * Get the persons interests
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Default true (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of interests to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\InterestPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInterestsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\InterestPagedResult';
        $request = $this->getInterestsForPersonRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\InterestPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInterestsForPersonAsync
     *
     * Get the persons interests
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Default true (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of interests to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInterestsForPersonAsync($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        return $this->getInterestsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInterestsForPersonAsyncWithHttpInfo
     *
     * Get the persons interests
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Default true (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of interests to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInterestsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\InterestPagedResult';
        $request = $this->getInterestsForPersonRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInterestsForPerson'
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Default true (optional, default to true)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of interests to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInterestsForPersonRequest($debtor_account_number, $token, $only_valid = 'true', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getInterestsForPerson'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getInterestsForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/interests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMembershipsForPerson
     *
     * Get a paged result of memberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the Person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid OBSOLETE: please use validity instead! (optional, default to true)
     * @param  \Membercare\Client\Model\SearchAssociatedValid $validity If this value is provided, onlyValid is ignored! ChooseDate is not supported  0 &#x3D; All  1 &#x3D; CurrentAndFuture  2 &#x3D; Current  3 &#x3D; ChooseDate (optional)
     * @param  bool $include_from_hierarchy We bring in the memberships from the companies where the person is currently employed (optional, default to false)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MembershipPagedResult
     */
    public function getMembershipsForPerson($debtor_account_number, $token, $only_valid = 'true', $validity = null, $include_from_hierarchy = 'false', $page = '1', $page_size = '50')
    {
        list($response) = $this->getMembershipsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid, $validity, $include_from_hierarchy, $page, $page_size);
        return $response;
    }

    /**
     * Operation getMembershipsForPersonWithHttpInfo
     *
     * Get a paged result of memberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the Person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid OBSOLETE: please use validity instead! (optional, default to true)
     * @param  \Membercare\Client\Model\SearchAssociatedValid $validity If this value is provided, onlyValid is ignored! ChooseDate is not supported  0 &#x3D; All  1 &#x3D; CurrentAndFuture  2 &#x3D; Current  3 &#x3D; ChooseDate (optional)
     * @param  bool $include_from_hierarchy We bring in the memberships from the companies where the person is currently employed (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MembershipPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMembershipsForPersonWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $validity = null, $include_from_hierarchy = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\MembershipPagedResult';
        $request = $this->getMembershipsForPersonRequest($debtor_account_number, $token, $only_valid, $validity, $include_from_hierarchy, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MembershipPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMembershipsForPersonAsync
     *
     * Get a paged result of memberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the Person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid OBSOLETE: please use validity instead! (optional, default to true)
     * @param  \Membercare\Client\Model\SearchAssociatedValid $validity If this value is provided, onlyValid is ignored! ChooseDate is not supported  0 &#x3D; All  1 &#x3D; CurrentAndFuture  2 &#x3D; Current  3 &#x3D; ChooseDate (optional)
     * @param  bool $include_from_hierarchy We bring in the memberships from the companies where the person is currently employed (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipsForPersonAsync($debtor_account_number, $token, $only_valid = 'true', $validity = null, $include_from_hierarchy = 'false', $page = '1', $page_size = '50')
    {
        return $this->getMembershipsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid, $validity, $include_from_hierarchy, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMembershipsForPersonAsyncWithHttpInfo
     *
     * Get a paged result of memberships.
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the Person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid OBSOLETE: please use validity instead! (optional, default to true)
     * @param  \Membercare\Client\Model\SearchAssociatedValid $validity If this value is provided, onlyValid is ignored! ChooseDate is not supported  0 &#x3D; All  1 &#x3D; CurrentAndFuture  2 &#x3D; Current  3 &#x3D; ChooseDate (optional)
     * @param  bool $include_from_hierarchy We bring in the memberships from the companies where the person is currently employed (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMembershipsForPersonAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'true', $validity = null, $include_from_hierarchy = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\MembershipPagedResult';
        $request = $this->getMembershipsForPersonRequest($debtor_account_number, $token, $only_valid, $validity, $include_from_hierarchy, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMembershipsForPerson'
     *
     * @param  string $debtor_account_number The debtorAccountNumber of the Person (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid OBSOLETE: please use validity instead! (optional, default to true)
     * @param  \Membercare\Client\Model\SearchAssociatedValid $validity If this value is provided, onlyValid is ignored! ChooseDate is not supported  0 &#x3D; All  1 &#x3D; CurrentAndFuture  2 &#x3D; Current  3 &#x3D; ChooseDate (optional)
     * @param  bool $include_from_hierarchy We bring in the memberships from the companies where the person is currently employed (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMembershipsForPersonRequest($debtor_account_number, $token, $only_valid = 'true', $validity = null, $include_from_hierarchy = 'false', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getMembershipsForPerson'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getMembershipsForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/memberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($validity !== null) {
            $queryParams['validity'] = ObjectSerializer::toQueryValue($validity, null);
        }
        // query params
        if ($include_from_hierarchy !== null) {
            $queryParams['includeFromHierarchy'] = ObjectSerializer::toQueryValue($include_from_hierarchy, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNotPersonAcceptedTerms
     *
     * Returns the Terms the Person has not accepted ordered by MajorVerson and MinorVersion
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Terms[]
     */
    public function getNotPersonAcceptedTerms($debtor_account_number, $token)
    {
        list($response) = $this->getNotPersonAcceptedTermsWithHttpInfo($debtor_account_number, $token);
        return $response;
    }

    /**
     * Operation getNotPersonAcceptedTermsWithHttpInfo
     *
     * Returns the Terms the Person has not accepted ordered by MajorVerson and MinorVersion
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Terms[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getNotPersonAcceptedTermsWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\Terms[]';
        $request = $this->getNotPersonAcceptedTermsRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Terms[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNotPersonAcceptedTermsAsync
     *
     * Returns the Terms the Person has not accepted ordered by MajorVerson and MinorVersion
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotPersonAcceptedTermsAsync($debtor_account_number, $token)
    {
        return $this->getNotPersonAcceptedTermsAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNotPersonAcceptedTermsAsyncWithHttpInfo
     *
     * Returns the Terms the Person has not accepted ordered by MajorVerson and MinorVersion
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNotPersonAcceptedTermsAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\Terms[]';
        $request = $this->getNotPersonAcceptedTermsRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNotPersonAcceptedTerms'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNotPersonAcceptedTermsRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getNotPersonAcceptedTerms'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getNotPersonAcceptedTerms'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/notAcceptedTerms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPasswordValidationRules
     *
     * Get PasswordValidationRules
     *
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\ConfigValue[]
     */
    public function getPasswordValidationRules($token)
    {
        list($response) = $this->getPasswordValidationRulesWithHttpInfo($token);
        return $response;
    }

    /**
     * Operation getPasswordValidationRulesWithHttpInfo
     *
     * Get PasswordValidationRules
     *
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\ConfigValue[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPasswordValidationRulesWithHttpInfo($token)
    {
        $returnType = '\Membercare\Client\Model\ConfigValue[]';
        $request = $this->getPasswordValidationRulesRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ConfigValue[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPasswordValidationRulesAsync
     *
     * Get PasswordValidationRules
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPasswordValidationRulesAsync($token)
    {
        return $this->getPasswordValidationRulesAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPasswordValidationRulesAsyncWithHttpInfo
     *
     * Get PasswordValidationRules
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPasswordValidationRulesAsyncWithHttpInfo($token)
    {
        $returnType = '\Membercare\Client\Model\ConfigValue[]';
        $request = $this->getPasswordValidationRulesRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPasswordValidationRules'
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPasswordValidationRulesRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPasswordValidationRules'
            );
        }

        $resourcePath = '/api/v1/persons/password/validationRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonAcceptedTerms
     *
     * Returns the newest Terms the Person has accepted
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Terms
     */
    public function getPersonAcceptedTerms($debtor_account_number, $token)
    {
        list($response) = $this->getPersonAcceptedTermsWithHttpInfo($debtor_account_number, $token);
        return $response;
    }

    /**
     * Operation getPersonAcceptedTermsWithHttpInfo
     *
     * Returns the newest Terms the Person has accepted
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Terms, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonAcceptedTermsWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\Terms';
        $request = $this->getPersonAcceptedTermsRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Terms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonAcceptedTermsAsync
     *
     * Returns the newest Terms the Person has accepted
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonAcceptedTermsAsync($debtor_account_number, $token)
    {
        return $this->getPersonAcceptedTermsAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonAcceptedTermsAsyncWithHttpInfo
     *
     * Returns the newest Terms the Person has accepted
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonAcceptedTermsAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\Terms';
        $request = $this->getPersonAcceptedTermsRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonAcceptedTerms'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonAcceptedTermsRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonAcceptedTerms'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonAcceptedTerms'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/acceptedTerms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonByLoginToken
     *
     * Retrieves a Person with the given loginToken
     *
     * @param  string $token access token (required)
     * @param  string $login_token The login token (optional)
     * @param  bool $include_name_history include_name_history (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function getPersonByLoginToken($token, $login_token = null, $include_name_history = 'false')
    {
        list($response) = $this->getPersonByLoginTokenWithHttpInfo($token, $login_token, $include_name_history);
        return $response;
    }

    /**
     * Operation getPersonByLoginTokenWithHttpInfo
     *
     * Retrieves a Person with the given loginToken
     *
     * @param  string $token access token (required)
     * @param  string $login_token The login token (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonByLoginTokenWithHttpInfo($token, $login_token = null, $include_name_history = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getPersonByLoginTokenRequest($token, $login_token, $include_name_history);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonByLoginTokenAsync
     *
     * Retrieves a Person with the given loginToken
     *
     * @param  string $token access token (required)
     * @param  string $login_token The login token (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonByLoginTokenAsync($token, $login_token = null, $include_name_history = 'false')
    {
        return $this->getPersonByLoginTokenAsyncWithHttpInfo($token, $login_token, $include_name_history)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonByLoginTokenAsyncWithHttpInfo
     *
     * Retrieves a Person with the given loginToken
     *
     * @param  string $token access token (required)
     * @param  string $login_token The login token (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonByLoginTokenAsyncWithHttpInfo($token, $login_token = null, $include_name_history = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getPersonByLoginTokenRequest($token, $login_token, $include_name_history);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonByLoginToken'
     *
     * @param  string $token access token (required)
     * @param  string $login_token The login token (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonByLoginTokenRequest($token, $login_token = null, $include_name_history = 'false')
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonByLoginToken'
            );
        }

        $resourcePath = '/api/v1/persons/search/by/loginToken';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($login_token !== null) {
            $queryParams['loginToken'] = ObjectSerializer::toQueryValue($login_token, null);
        }
        // query params
        if ($include_name_history !== null) {
            $queryParams['includeNameHistory'] = ObjectSerializer::toQueryValue($include_name_history, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonCloseReasons
     *
     * Returns a list of CloseReasons
     *
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\CloseReason[]
     */
    public function getPersonCloseReasons($token)
    {
        list($response) = $this->getPersonCloseReasonsWithHttpInfo($token);
        return $response;
    }

    /**
     * Operation getPersonCloseReasonsWithHttpInfo
     *
     * Returns a list of CloseReasons
     *
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\CloseReason[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonCloseReasonsWithHttpInfo($token)
    {
        $returnType = '\Membercare\Client\Model\CloseReason[]';
        $request = $this->getPersonCloseReasonsRequest($token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\CloseReason[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonCloseReasonsAsync
     *
     * Returns a list of CloseReasons
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonCloseReasonsAsync($token)
    {
        return $this->getPersonCloseReasonsAsyncWithHttpInfo($token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonCloseReasonsAsyncWithHttpInfo
     *
     * Returns a list of CloseReasons
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonCloseReasonsAsyncWithHttpInfo($token)
    {
        $returnType = '\Membercare\Client\Model\CloseReason[]';
        $request = $this->getPersonCloseReasonsRequest($token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonCloseReasons'
     *
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonCloseReasonsRequest($token)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonCloseReasons'
            );
        }

        $resourcePath = '/api/v1/persons/closeReasons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonConsents
     *
     * Returns all consents for this person
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $skip_text skip_text (optional)
     * @param  bool $skip_summary skip_summary (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Consent[]
     */
    public function getPersonConsents($debtor_account_number, $token, $skip_text = null, $skip_summary = null)
    {
        list($response) = $this->getPersonConsentsWithHttpInfo($debtor_account_number, $token, $skip_text, $skip_summary);
        return $response;
    }

    /**
     * Operation getPersonConsentsWithHttpInfo
     *
     * Returns all consents for this person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $skip_text (optional)
     * @param  bool $skip_summary (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Consent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonConsentsWithHttpInfo($debtor_account_number, $token, $skip_text = null, $skip_summary = null)
    {
        $returnType = '\Membercare\Client\Model\Consent[]';
        $request = $this->getPersonConsentsRequest($debtor_account_number, $token, $skip_text, $skip_summary);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Consent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonConsentsAsync
     *
     * Returns all consents for this person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $skip_text (optional)
     * @param  bool $skip_summary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonConsentsAsync($debtor_account_number, $token, $skip_text = null, $skip_summary = null)
    {
        return $this->getPersonConsentsAsyncWithHttpInfo($debtor_account_number, $token, $skip_text, $skip_summary)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonConsentsAsyncWithHttpInfo
     *
     * Returns all consents for this person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $skip_text (optional)
     * @param  bool $skip_summary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonConsentsAsyncWithHttpInfo($debtor_account_number, $token, $skip_text = null, $skip_summary = null)
    {
        $returnType = '\Membercare\Client\Model\Consent[]';
        $request = $this->getPersonConsentsRequest($debtor_account_number, $token, $skip_text, $skip_summary);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonConsents'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $skip_text (optional)
     * @param  bool $skip_summary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonConsentsRequest($debtor_account_number, $token, $skip_text = null, $skip_summary = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonConsents'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonConsents'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/consents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($skip_text !== null) {
            $queryParams['skipText'] = ObjectSerializer::toQueryValue($skip_text, null);
        }
        // query params
        if ($skip_summary !== null) {
            $queryParams['skipSummary'] = ObjectSerializer::toQueryValue($skip_summary, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonDocuments
     *
     * Returns a list ot person documents
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $include_content include_content (optional)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonDocumentPagedResult
     */
    public function getPersonDocuments($debtor_account_number, $token, $include_content = null, $page = '1', $page_size = '50')
    {
        list($response) = $this->getPersonDocumentsWithHttpInfo($debtor_account_number, $token, $include_content, $page, $page_size);
        return $response;
    }

    /**
     * Operation getPersonDocumentsWithHttpInfo
     *
     * Returns a list ot person documents
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $include_content (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonDocumentPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonDocumentsWithHttpInfo($debtor_account_number, $token, $include_content = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonDocumentPagedResult';
        $request = $this->getPersonDocumentsRequest($debtor_account_number, $token, $include_content, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonDocumentPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonDocumentsAsync
     *
     * Returns a list ot person documents
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $include_content (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonDocumentsAsync($debtor_account_number, $token, $include_content = null, $page = '1', $page_size = '50')
    {
        return $this->getPersonDocumentsAsyncWithHttpInfo($debtor_account_number, $token, $include_content, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonDocumentsAsyncWithHttpInfo
     *
     * Returns a list ot person documents
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $include_content (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonDocumentsAsyncWithHttpInfo($debtor_account_number, $token, $include_content = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonDocumentPagedResult';
        $request = $this->getPersonDocumentsRequest($debtor_account_number, $token, $include_content, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonDocuments'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  bool $include_content (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonDocumentsRequest($debtor_account_number, $token, $include_content = null, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonDocuments'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonDocuments'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_content !== null) {
            $queryParams['includeContent'] = ObjectSerializer::toQueryValue($include_content, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonForeignSystem
     *
     * Get Persons via ForeginSystem
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  int $id id (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function getPersonForeignSystem($debtor_account_number, $id, $token)
    {
        list($response) = $this->getPersonForeignSystemWithHttpInfo($debtor_account_number, $id, $token);
        return $response;
    }

    /**
     * Operation getPersonForeignSystemWithHttpInfo
     *
     * Get Persons via ForeginSystem
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonForeignSystemWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getPersonForeignSystemRequest($debtor_account_number, $id, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonForeignSystemAsync
     *
     * Get Persons via ForeginSystem
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonForeignSystemAsync($debtor_account_number, $id, $token)
    {
        return $this->getPersonForeignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonForeignSystemAsyncWithHttpInfo
     *
     * Get Persons via ForeginSystem
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonForeignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->getPersonForeignSystemRequest($debtor_account_number, $id, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonForeignSystem'
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonForeignSystemRequest($debtor_account_number, $id, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonForeignSystem'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getPersonForeignSystem'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonForeignSystem'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/foreignSystem/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonMembercareUser
     *
     * Gets a list of MembercareUsers for a person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MembercareUser[]
     */
    public function getPersonMembercareUser($debtor_account_number, $token)
    {
        list($response) = $this->getPersonMembercareUserWithHttpInfo($debtor_account_number, $token);
        return $response;
    }

    /**
     * Operation getPersonMembercareUserWithHttpInfo
     *
     * Gets a list of MembercareUsers for a person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MembercareUser[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonMembercareUserWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser[]';
        $request = $this->getPersonMembercareUserRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MembercareUser[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonMembercareUserAsync
     *
     * Gets a list of MembercareUsers for a person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonMembercareUserAsync($debtor_account_number, $token)
    {
        return $this->getPersonMembercareUserAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonMembercareUserAsyncWithHttpInfo
     *
     * Gets a list of MembercareUsers for a person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonMembercareUserAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser[]';
        $request = $this->getPersonMembercareUserRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonMembercareUser'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonMembercareUserRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonMembercareUser'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonMembercareUser'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/membercareUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonParticipations
     *
     * Gets participations for a given person
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $arrangement_starts_after arrangement_starts_after (optional)
     * @param  \DateTime $arrangement_starts_before arrangement_starts_before (optional)
     * @param  \DateTime $arrangement_ends_after arrangement_ends_after (optional)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\ParticipantPagedResult
     */
    public function getPersonParticipations($debtor_account_number, $token, $arrangement_starts_after = null, $arrangement_starts_before = null, $arrangement_ends_after = null, $page = '1', $page_size = '50')
    {
        list($response) = $this->getPersonParticipationsWithHttpInfo($debtor_account_number, $token, $arrangement_starts_after, $arrangement_starts_before, $arrangement_ends_after, $page, $page_size);
        return $response;
    }

    /**
     * Operation getPersonParticipationsWithHttpInfo
     *
     * Gets participations for a given person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $arrangement_starts_after (optional)
     * @param  \DateTime $arrangement_starts_before (optional)
     * @param  \DateTime $arrangement_ends_after (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\ParticipantPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonParticipationsWithHttpInfo($debtor_account_number, $token, $arrangement_starts_after = null, $arrangement_starts_before = null, $arrangement_ends_after = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\ParticipantPagedResult';
        $request = $this->getPersonParticipationsRequest($debtor_account_number, $token, $arrangement_starts_after, $arrangement_starts_before, $arrangement_ends_after, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ParticipantPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonParticipationsAsync
     *
     * Gets participations for a given person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $arrangement_starts_after (optional)
     * @param  \DateTime $arrangement_starts_before (optional)
     * @param  \DateTime $arrangement_ends_after (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonParticipationsAsync($debtor_account_number, $token, $arrangement_starts_after = null, $arrangement_starts_before = null, $arrangement_ends_after = null, $page = '1', $page_size = '50')
    {
        return $this->getPersonParticipationsAsyncWithHttpInfo($debtor_account_number, $token, $arrangement_starts_after, $arrangement_starts_before, $arrangement_ends_after, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonParticipationsAsyncWithHttpInfo
     *
     * Gets participations for a given person
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $arrangement_starts_after (optional)
     * @param  \DateTime $arrangement_starts_before (optional)
     * @param  \DateTime $arrangement_ends_after (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonParticipationsAsyncWithHttpInfo($debtor_account_number, $token, $arrangement_starts_after = null, $arrangement_starts_before = null, $arrangement_ends_after = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\ParticipantPagedResult';
        $request = $this->getPersonParticipationsRequest($debtor_account_number, $token, $arrangement_starts_after, $arrangement_starts_before, $arrangement_ends_after, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonParticipations'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $arrangement_starts_after (optional)
     * @param  \DateTime $arrangement_starts_before (optional)
     * @param  \DateTime $arrangement_ends_after (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonParticipationsRequest($debtor_account_number, $token, $arrangement_starts_after = null, $arrangement_starts_before = null, $arrangement_ends_after = null, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonParticipations'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonParticipations'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/participations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($arrangement_starts_after !== null) {
            $queryParams['arrangementStartsAfter'] = ObjectSerializer::toQueryValue($arrangement_starts_after, 'date-time');
        }
        // query params
        if ($arrangement_starts_before !== null) {
            $queryParams['arrangementStartsBefore'] = ObjectSerializer::toQueryValue($arrangement_starts_before, 'date-time');
        }
        // query params
        if ($arrangement_ends_after !== null) {
            $queryParams['arrangementEndsAfter'] = ObjectSerializer::toQueryValue($arrangement_ends_after, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonProfilePicture
     *
     * Gets a person profile picture
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonProfilePicture
     */
    public function getPersonProfilePicture($debtor_account_number, $token)
    {
        list($response) = $this->getPersonProfilePictureWithHttpInfo($debtor_account_number, $token);
        return $response;
    }

    /**
     * Operation getPersonProfilePictureWithHttpInfo
     *
     * Gets a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonProfilePicture, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonProfilePictureWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\PersonProfilePicture';
        $request = $this->getPersonProfilePictureRequest($debtor_account_number, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonProfilePicture',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonProfilePictureAsync
     *
     * Gets a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonProfilePictureAsync($debtor_account_number, $token)
    {
        return $this->getPersonProfilePictureAsyncWithHttpInfo($debtor_account_number, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonProfilePictureAsyncWithHttpInfo
     *
     * Gets a person profile picture
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonProfilePictureAsyncWithHttpInfo($debtor_account_number, $token)
    {
        $returnType = '\Membercare\Client\Model\PersonProfilePicture';
        $request = $this->getPersonProfilePictureRequest($debtor_account_number, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonProfilePicture'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonProfilePictureRequest($debtor_account_number, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonProfilePicture'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonProfilePicture'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/profilePicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonSubscriptions
     *
     * Get a persons subscriptions
     *
     * @param  string $debtor_account_number The debtor account number of the person to get subscriptions for (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to only include valid subscriptions. (optional, default to true)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Subscription[]
     */
    public function getPersonSubscriptions($debtor_account_number, $token, $only_valid = 'true')
    {
        list($response) = $this->getPersonSubscriptionsWithHttpInfo($debtor_account_number, $token, $only_valid);
        return $response;
    }

    /**
     * Operation getPersonSubscriptionsWithHttpInfo
     *
     * Get a persons subscriptions
     *
     * @param  string $debtor_account_number The debtor account number of the person to get subscriptions for (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to only include valid subscriptions. (optional, default to true)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Subscription[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonSubscriptionsWithHttpInfo($debtor_account_number, $token, $only_valid = 'true')
    {
        $returnType = '\Membercare\Client\Model\Subscription[]';
        $request = $this->getPersonSubscriptionsRequest($debtor_account_number, $token, $only_valid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Subscription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonSubscriptionsAsync
     *
     * Get a persons subscriptions
     *
     * @param  string $debtor_account_number The debtor account number of the person to get subscriptions for (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to only include valid subscriptions. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonSubscriptionsAsync($debtor_account_number, $token, $only_valid = 'true')
    {
        return $this->getPersonSubscriptionsAsyncWithHttpInfo($debtor_account_number, $token, $only_valid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonSubscriptionsAsyncWithHttpInfo
     *
     * Get a persons subscriptions
     *
     * @param  string $debtor_account_number The debtor account number of the person to get subscriptions for (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to only include valid subscriptions. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonSubscriptionsAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'true')
    {
        $returnType = '\Membercare\Client\Model\Subscription[]';
        $request = $this->getPersonSubscriptionsRequest($debtor_account_number, $token, $only_valid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonSubscriptions'
     *
     * @param  string $debtor_account_number The debtor account number of the person to get subscriptions for (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Indicates whether or not to only include valid subscriptions. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonSubscriptionsRequest($debtor_account_number, $token, $only_valid = 'true')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getPersonSubscriptions'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonSubscriptions'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersons
     *
     * Retrieves a list of all Persons
     *
     * @param  string $token access token (required)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     * @param  bool $include_employments include_employments (optional, default to false)
     * @param  bool $include_memberships include_memberships (optional, default to false)
     * @param  bool $include_board_memberships include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups include_union_groups (optional, default to false)
     * @param  bool $only_valid only_valid (optional, default to true)
     * @param  bool $include_custom_fields include_custom_fields (optional, default to false)
     * @param  bool $include_interests include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification include_profile_picture_identification (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonPagedResult
     */
    public function getPersons($token, $page = '1', $page_size = '50', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $only_valid = 'true', $include_custom_fields = 'false', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        list($response) = $this->getPersonsWithHttpInfo($token, $page, $page_size, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $only_valid, $include_custom_fields, $include_interests, $include_profile_picture_identification);
        return $response;
    }

    /**
     * Operation getPersonsWithHttpInfo
     *
     * Retrieves a list of all Persons
     *
     * @param  string $token access token (required)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonsWithHttpInfo($token, $page = '1', $page_size = '50', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $only_valid = 'true', $include_custom_fields = 'false', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->getPersonsRequest($token, $page, $page_size, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $only_valid, $include_custom_fields, $include_interests, $include_profile_picture_identification);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonsAsync
     *
     * Retrieves a list of all Persons
     *
     * @param  string $token access token (required)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonsAsync($token, $page = '1', $page_size = '50', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $only_valid = 'true', $include_custom_fields = 'false', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        return $this->getPersonsAsyncWithHttpInfo($token, $page, $page_size, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $only_valid, $include_custom_fields, $include_interests, $include_profile_picture_identification)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonsAsyncWithHttpInfo
     *
     * Retrieves a list of all Persons
     *
     * @param  string $token access token (required)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonsAsyncWithHttpInfo($token, $page = '1', $page_size = '50', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $only_valid = 'true', $include_custom_fields = 'false', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->getPersonsRequest($token, $page, $page_size, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $only_valid, $include_custom_fields, $include_interests, $include_profile_picture_identification);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersons'
     *
     * @param  string $token access token (required)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonsRequest($token, $page = '1', $page_size = '50', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $only_valid = 'true', $include_custom_fields = 'false', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersons'
            );
        }

        $resourcePath = '/api/v1/persons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // query params
        if ($include_employments !== null) {
            $queryParams['includeEmployments'] = ObjectSerializer::toQueryValue($include_employments, null);
        }
        // query params
        if ($include_memberships !== null) {
            $queryParams['includeMemberships'] = ObjectSerializer::toQueryValue($include_memberships, null);
        }
        // query params
        if ($include_board_memberships !== null) {
            $queryParams['includeBoardMemberships'] = ObjectSerializer::toQueryValue($include_board_memberships, null);
        }
        // query params
        if ($include_union_representatives !== null) {
            $queryParams['includeUnionRepresentatives'] = ObjectSerializer::toQueryValue($include_union_representatives, null);
        }
        // query params
        if ($include_union_groups !== null) {
            $queryParams['includeUnionGroups'] = ObjectSerializer::toQueryValue($include_union_groups, null);
        }
        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($include_custom_fields !== null) {
            $queryParams['includeCustomFields'] = ObjectSerializer::toQueryValue($include_custom_fields, null);
        }
        // query params
        if ($include_interests !== null) {
            $queryParams['includeInterests'] = ObjectSerializer::toQueryValue($include_interests, null);
        }
        // query params
        if ($include_profile_picture_identification !== null) {
            $queryParams['includeProfilePictureIdentification'] = ObjectSerializer::toQueryValue($include_profile_picture_identification, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPersonsByUserIdentification
     *
     * Returns persons with the given UserIdentification if found
     *
     * @param  string $user_identification user_identification (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid only_valid (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person[]
     */
    public function getPersonsByUserIdentification($user_identification, $token, $only_valid = 'false')
    {
        list($response) = $this->getPersonsByUserIdentificationWithHttpInfo($user_identification, $token, $only_valid);
        return $response;
    }

    /**
     * Operation getPersonsByUserIdentificationWithHttpInfo
     *
     * Returns persons with the given UserIdentification if found
     *
     * @param  string $user_identification (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getPersonsByUserIdentificationWithHttpInfo($user_identification, $token, $only_valid = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person[]';
        $request = $this->getPersonsByUserIdentificationRequest($user_identification, $token, $only_valid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPersonsByUserIdentificationAsync
     *
     * Returns persons with the given UserIdentification if found
     *
     * @param  string $user_identification (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonsByUserIdentificationAsync($user_identification, $token, $only_valid = 'false')
    {
        return $this->getPersonsByUserIdentificationAsyncWithHttpInfo($user_identification, $token, $only_valid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPersonsByUserIdentificationAsyncWithHttpInfo
     *
     * Returns persons with the given UserIdentification if found
     *
     * @param  string $user_identification (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPersonsByUserIdentificationAsyncWithHttpInfo($user_identification, $token, $only_valid = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person[]';
        $request = $this->getPersonsByUserIdentificationRequest($user_identification, $token, $only_valid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPersonsByUserIdentification'
     *
     * @param  string $user_identification (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPersonsByUserIdentificationRequest($user_identification, $token, $only_valid = 'false')
    {
        // verify the required parameter 'user_identification' is set
        if ($user_identification === null || (is_array($user_identification) && count($user_identification) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_identification when calling getPersonsByUserIdentification'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getPersonsByUserIdentification'
            );
        }

        $resourcePath = '/api/v1/persons/search/by/userIdentification/{userIdentification}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($user_identification !== null) {
            $resourcePath = str_replace(
                '{' . 'userIdentification' . '}',
                ObjectSerializer::toPathValue($user_identification),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getUnionRepresentativesByDebtorAccountNumber
     *
     * Gets all representatives of the person with given debtor account number
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $validity_date validity_date (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\UnionRepresentative[]
     */
    public function getUnionRepresentativesByDebtorAccountNumber($debtor_account_number, $token, $validity_date = null)
    {
        list($response) = $this->getUnionRepresentativesByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token, $validity_date);
        return $response;
    }

    /**
     * Operation getUnionRepresentativesByDebtorAccountNumberWithHttpInfo
     *
     * Gets all representatives of the person with given debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $validity_date (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\UnionRepresentative[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getUnionRepresentativesByDebtorAccountNumberWithHttpInfo($debtor_account_number, $token, $validity_date = null)
    {
        $returnType = '\Membercare\Client\Model\UnionRepresentative[]';
        $request = $this->getUnionRepresentativesByDebtorAccountNumberRequest($debtor_account_number, $token, $validity_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\UnionRepresentative[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getUnionRepresentativesByDebtorAccountNumberAsync
     *
     * Gets all representatives of the person with given debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $validity_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnionRepresentativesByDebtorAccountNumberAsync($debtor_account_number, $token, $validity_date = null)
    {
        return $this->getUnionRepresentativesByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token, $validity_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getUnionRepresentativesByDebtorAccountNumberAsyncWithHttpInfo
     *
     * Gets all representatives of the person with given debtor account number
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $validity_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getUnionRepresentativesByDebtorAccountNumberAsyncWithHttpInfo($debtor_account_number, $token, $validity_date = null)
    {
        $returnType = '\Membercare\Client\Model\UnionRepresentative[]';
        $request = $this->getUnionRepresentativesByDebtorAccountNumberRequest($debtor_account_number, $token, $validity_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getUnionRepresentativesByDebtorAccountNumber'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  \DateTime $validity_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getUnionRepresentativesByDebtorAccountNumberRequest($debtor_account_number, $token, $validity_date = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling getUnionRepresentativesByDebtorAccountNumber'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getUnionRepresentativesByDebtorAccountNumber'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/unionrepresentatives';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($validity_date !== null) {
            $queryParams['validityDate'] = ObjectSerializer::toQueryValue($validity_date, 'date-time');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getValidatePasswordResult
     *
     * Will validate the password
     *
     * @param  string $token access token (required)
     * @param  string $password password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PasswordValidationError[]
     */
    public function getValidatePasswordResult($token, $password = null)
    {
        list($response) = $this->getValidatePasswordResultWithHttpInfo($token, $password);
        return $response;
    }

    /**
     * Operation getValidatePasswordResultWithHttpInfo
     *
     * Will validate the password
     *
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PasswordValidationError[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getValidatePasswordResultWithHttpInfo($token, $password = null)
    {
        $returnType = '\Membercare\Client\Model\PasswordValidationError[]';
        $request = $this->getValidatePasswordResultRequest($token, $password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PasswordValidationError[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getValidatePasswordResultAsync
     *
     * Will validate the password
     *
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getValidatePasswordResultAsync($token, $password = null)
    {
        return $this->getValidatePasswordResultAsyncWithHttpInfo($token, $password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getValidatePasswordResultAsyncWithHttpInfo
     *
     * Will validate the password
     *
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getValidatePasswordResultAsyncWithHttpInfo($token, $password = null)
    {
        $returnType = '\Membercare\Client\Model\PasswordValidationError[]';
        $request = $this->getValidatePasswordResultRequest($token, $password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getValidatePasswordResult'
     *
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getValidatePasswordResultRequest($token, $password = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling getValidatePasswordResult'
            );
        }

        $resourcePath = '/api/v1/persons/password/validator';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPassword
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patchPassword($debtor_account_number, $token, $password = null)
    {
        $this->patchPasswordWithHttpInfo($debtor_account_number, $token, $password);
    }

    /**
     * Operation patchPasswordWithHttpInfo
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPasswordWithHttpInfo($debtor_account_number, $token, $password = null)
    {
        $returnType = '';
        $request = $this->patchPasswordRequest($debtor_account_number, $token, $password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPasswordAsync
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPasswordAsync($debtor_account_number, $token, $password = null)
    {
        return $this->patchPasswordAsyncWithHttpInfo($debtor_account_number, $token, $password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPasswordAsyncWithHttpInfo
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPasswordAsyncWithHttpInfo($debtor_account_number, $token, $password = null)
    {
        $returnType = '';
        $request = $this->patchPasswordRequest($debtor_account_number, $token, $password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPassword'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchPasswordRequest($debtor_account_number, $token, $password = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling patchPassword'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling patchPassword'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPerson
     *
     * Tries to Patch a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonPatch $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function patchPerson($token, $debtor_account_number, $body = null)
    {
        $this->patchPersonWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation patchPersonWithHttpInfo
     *
     * Tries to Patch a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonPatch $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->patchPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPersonAsync
     *
     * Tries to Patch a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->patchPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPersonAsyncWithHttpInfo
     *
     * Tries to Patch a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->patchPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling patchPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling patchPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPersonConsent
     *
     * Patch Accepted for a Consent associated with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Consent
     */
    public function patchPersonConsent($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->patchPersonConsentWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation patchPersonConsentWithHttpInfo
     *
     * Patch Accepted for a Consent associated with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Consent, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPersonConsentWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Consent';
        $request = $this->patchPersonConsentRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Consent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPersonConsentAsync
     *
     * Patch Accepted for a Consent associated with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonConsentAsync($token, $debtor_account_number, $body = null)
    {
        return $this->patchPersonConsentAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPersonConsentAsyncWithHttpInfo
     *
     * Patch Accepted for a Consent associated with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonConsentAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Consent';
        $request = $this->patchPersonConsentRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPersonConsent'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchPersonConsentRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling patchPersonConsent'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling patchPersonConsent'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/consent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation patchPersonMembercareUser
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUserPatch $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MembercareUser
     */
    public function patchPersonMembercareUser($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->patchPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation patchPersonMembercareUserWithHttpInfo
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUserPatch $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MembercareUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function patchPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->patchPersonMembercareUserRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MembercareUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation patchPersonMembercareUserAsync
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUserPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonMembercareUserAsync($token, $debtor_account_number, $body = null)
    {
        return $this->patchPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation patchPersonMembercareUserAsyncWithHttpInfo
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUserPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function patchPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->patchPersonMembercareUserRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'patchPersonMembercareUser'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUserPatch $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function patchPersonMembercareUserRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling patchPersonMembercareUser'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling patchPersonMembercareUser'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/membercareUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personApi
     *
     * Retrieves a Person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number The Members DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $include_name_history include_name_history (optional, default to false)
     * @param  bool $include_employments include_employments (optional, default to false)
     * @param  bool $include_memberships include_memberships (optional, default to false)
     * @param  bool $include_board_memberships include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups include_union_groups (optional, default to false)
     * @param  bool $include_custom_fields include_custom_fields (optional, default to false)
     * @param  bool $only_valid only_valid (optional, default to true)
     * @param  bool $include_interests include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification include_profile_picture_identification (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function personApi($debtor_account_number, $token, $include_name_history = 'false', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $include_custom_fields = 'false', $only_valid = 'true', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        list($response) = $this->personApiWithHttpInfo($debtor_account_number, $token, $include_name_history, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $include_custom_fields, $only_valid, $include_interests, $include_profile_picture_identification);
        return $response;
    }

    /**
     * Operation personApiWithHttpInfo
     *
     * Retrieves a Person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number The Members DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $include_name_history (optional, default to false)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function personApiWithHttpInfo($debtor_account_number, $token, $include_name_history = 'false', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $include_custom_fields = 'false', $only_valid = 'true', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->personApiRequest($debtor_account_number, $token, $include_name_history, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $include_custom_fields, $only_valid, $include_interests, $include_profile_picture_identification);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personApiAsync
     *
     * Retrieves a Person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number The Members DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $include_name_history (optional, default to false)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personApiAsync($debtor_account_number, $token, $include_name_history = 'false', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $include_custom_fields = 'false', $only_valid = 'true', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        return $this->personApiAsyncWithHttpInfo($debtor_account_number, $token, $include_name_history, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $include_custom_fields, $only_valid, $include_interests, $include_profile_picture_identification)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personApiAsyncWithHttpInfo
     *
     * Retrieves a Person with the given DebtorAccountNumber
     *
     * @param  string $debtor_account_number The Members DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $include_name_history (optional, default to false)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personApiAsyncWithHttpInfo($debtor_account_number, $token, $include_name_history = 'false', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $include_custom_fields = 'false', $only_valid = 'true', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->personApiRequest($debtor_account_number, $token, $include_name_history, $include_employments, $include_memberships, $include_board_memberships, $include_union_representatives, $include_union_groups, $include_custom_fields, $only_valid, $include_interests, $include_profile_picture_identification);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personApi'
     *
     * @param  string $debtor_account_number The Members DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $include_name_history (optional, default to false)
     * @param  bool $include_employments (optional, default to false)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_union_representatives (optional, default to false)
     * @param  bool $include_union_groups (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $only_valid (optional, default to true)
     * @param  bool $include_interests (optional, default to false)
     * @param  bool $include_profile_picture_identification (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personApiRequest($debtor_account_number, $token, $include_name_history = 'false', $include_employments = 'false', $include_memberships = 'false', $include_board_memberships = 'false', $include_union_representatives = 'false', $include_union_groups = 'false', $include_custom_fields = 'false', $only_valid = 'true', $include_interests = 'false', $include_profile_picture_identification = 'false')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling personApi'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personApi'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_name_history !== null) {
            $queryParams['includeNameHistory'] = ObjectSerializer::toQueryValue($include_name_history, null);
        }
        // query params
        if ($include_employments !== null) {
            $queryParams['includeEmployments'] = ObjectSerializer::toQueryValue($include_employments, null);
        }
        // query params
        if ($include_memberships !== null) {
            $queryParams['includeMemberships'] = ObjectSerializer::toQueryValue($include_memberships, null);
        }
        // query params
        if ($include_board_memberships !== null) {
            $queryParams['includeBoardMemberships'] = ObjectSerializer::toQueryValue($include_board_memberships, null);
        }
        // query params
        if ($include_union_representatives !== null) {
            $queryParams['includeUnionRepresentatives'] = ObjectSerializer::toQueryValue($include_union_representatives, null);
        }
        // query params
        if ($include_union_groups !== null) {
            $queryParams['includeUnionGroups'] = ObjectSerializer::toQueryValue($include_union_groups, null);
        }
        // query params
        if ($include_custom_fields !== null) {
            $queryParams['includeCustomFields'] = ObjectSerializer::toQueryValue($include_custom_fields, null);
        }
        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($include_interests !== null) {
            $queryParams['includeInterests'] = ObjectSerializer::toQueryValue($include_interests, null);
        }
        // query params
        if ($include_profile_picture_identification !== null) {
            $queryParams['includeProfilePictureIdentification'] = ObjectSerializer::toQueryValue($include_profile_picture_identification, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personByBirthdateAndLastFour
     *
     * Retrieves a person by birthdate and lastfour (from social security number)
     *
     * @param  int $year The year of the birthdate. (required)
     * @param  int $month The month of the birthdate. (required)
     * @param  int $day The day of the birthdate. (required)
     * @param  string $token access token (required)
     * @param  string $lastfour The last four numbers from a social security number (optional)
     * @param  string $last_five The last five numbers from a social security number (Norway) (optional)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonPagedResult
     */
    public function personByBirthdateAndLastFour($year, $month, $day, $token, $lastfour = null, $last_five = null, $page = '1', $page_size = '50')
    {
        list($response) = $this->personByBirthdateAndLastFourWithHttpInfo($year, $month, $day, $token, $lastfour, $last_five, $page, $page_size);
        return $response;
    }

    /**
     * Operation personByBirthdateAndLastFourWithHttpInfo
     *
     * Retrieves a person by birthdate and lastfour (from social security number)
     *
     * @param  int $year The year of the birthdate. (required)
     * @param  int $month The month of the birthdate. (required)
     * @param  int $day The day of the birthdate. (required)
     * @param  string $token access token (required)
     * @param  string $lastfour The last four numbers from a social security number (optional)
     * @param  string $last_five The last five numbers from a social security number (Norway) (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function personByBirthdateAndLastFourWithHttpInfo($year, $month, $day, $token, $lastfour = null, $last_five = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->personByBirthdateAndLastFourRequest($year, $month, $day, $token, $lastfour, $last_five, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personByBirthdateAndLastFourAsync
     *
     * Retrieves a person by birthdate and lastfour (from social security number)
     *
     * @param  int $year The year of the birthdate. (required)
     * @param  int $month The month of the birthdate. (required)
     * @param  int $day The day of the birthdate. (required)
     * @param  string $token access token (required)
     * @param  string $lastfour The last four numbers from a social security number (optional)
     * @param  string $last_five The last five numbers from a social security number (Norway) (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personByBirthdateAndLastFourAsync($year, $month, $day, $token, $lastfour = null, $last_five = null, $page = '1', $page_size = '50')
    {
        return $this->personByBirthdateAndLastFourAsyncWithHttpInfo($year, $month, $day, $token, $lastfour, $last_five, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personByBirthdateAndLastFourAsyncWithHttpInfo
     *
     * Retrieves a person by birthdate and lastfour (from social security number)
     *
     * @param  int $year The year of the birthdate. (required)
     * @param  int $month The month of the birthdate. (required)
     * @param  int $day The day of the birthdate. (required)
     * @param  string $token access token (required)
     * @param  string $lastfour The last four numbers from a social security number (optional)
     * @param  string $last_five The last five numbers from a social security number (Norway) (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personByBirthdateAndLastFourAsyncWithHttpInfo($year, $month, $day, $token, $lastfour = null, $last_five = null, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->personByBirthdateAndLastFourRequest($year, $month, $day, $token, $lastfour, $last_five, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personByBirthdateAndLastFour'
     *
     * @param  int $year The year of the birthdate. (required)
     * @param  int $month The month of the birthdate. (required)
     * @param  int $day The day of the birthdate. (required)
     * @param  string $token access token (required)
     * @param  string $lastfour The last four numbers from a social security number (optional)
     * @param  string $last_five The last five numbers from a social security number (Norway) (optional)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personByBirthdateAndLastFourRequest($year, $month, $day, $token, $lastfour = null, $last_five = null, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'year' is set
        if ($year === null || (is_array($year) && count($year) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $year when calling personByBirthdateAndLastFour'
            );
        }
        // verify the required parameter 'month' is set
        if ($month === null || (is_array($month) && count($month) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $month when calling personByBirthdateAndLastFour'
            );
        }
        // verify the required parameter 'day' is set
        if ($day === null || (is_array($day) && count($day) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $day when calling personByBirthdateAndLastFour'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personByBirthdateAndLastFour'
            );
        }

        $resourcePath = '/api/v1/persons/birthdate/{year}/{month}/{day}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($lastfour !== null) {
            $queryParams['lastfour'] = ObjectSerializer::toQueryValue($lastfour, null);
        }
        // query params
        if ($last_five !== null) {
            $queryParams['lastFive'] = ObjectSerializer::toQueryValue($last_five, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($year !== null) {
            $resourcePath = str_replace(
                '{' . 'year' . '}',
                ObjectSerializer::toPathValue($year),
                $resourcePath
            );
        }
        // path params
        if ($month !== null) {
            $resourcePath = str_replace(
                '{' . 'month' . '}',
                ObjectSerializer::toPathValue($month),
                $resourcePath
            );
        }
        // path params
        if ($day !== null) {
            $resourcePath = str_replace(
                '{' . 'day' . '}',
                ObjectSerializer::toPathValue($day),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personByExternalIdApi
     *
     * Retrieves a Person with the given ExternalId
     *
     * @param  string $token access token (required)
     * @param  string $external_id The Members ExternalId (optional)
     * @param  bool $include_name_history include_name_history (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function personByExternalIdApi($token, $external_id = null, $include_name_history = 'false')
    {
        list($response) = $this->personByExternalIdApiWithHttpInfo($token, $external_id, $include_name_history);
        return $response;
    }

    /**
     * Operation personByExternalIdApiWithHttpInfo
     *
     * Retrieves a Person with the given ExternalId
     *
     * @param  string $token access token (required)
     * @param  string $external_id The Members ExternalId (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function personByExternalIdApiWithHttpInfo($token, $external_id = null, $include_name_history = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->personByExternalIdApiRequest($token, $external_id, $include_name_history);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personByExternalIdApiAsync
     *
     * Retrieves a Person with the given ExternalId
     *
     * @param  string $token access token (required)
     * @param  string $external_id The Members ExternalId (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personByExternalIdApiAsync($token, $external_id = null, $include_name_history = 'false')
    {
        return $this->personByExternalIdApiAsyncWithHttpInfo($token, $external_id, $include_name_history)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personByExternalIdApiAsyncWithHttpInfo
     *
     * Retrieves a Person with the given ExternalId
     *
     * @param  string $token access token (required)
     * @param  string $external_id The Members ExternalId (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personByExternalIdApiAsyncWithHttpInfo($token, $external_id = null, $include_name_history = 'false')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->personByExternalIdApiRequest($token, $external_id, $include_name_history);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personByExternalIdApi'
     *
     * @param  string $token access token (required)
     * @param  string $external_id The Members ExternalId (optional)
     * @param  bool $include_name_history (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personByExternalIdApiRequest($token, $external_id = null, $include_name_history = 'false')
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personByExternalIdApi'
            );
        }

        $resourcePath = '/api/v1/persons/search/by/externalid';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($external_id !== null) {
            $queryParams['externalId'] = ObjectSerializer::toQueryValue($external_id, null);
        }
        // query params
        if ($include_name_history !== null) {
            $queryParams['includeNameHistory'] = ObjectSerializer::toQueryValue($include_name_history, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personEmploymentApi
     *
     * Retrieves a employment that the person have, from the given id.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  int $id The Id of the wanted employment (EmploymentId) (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Employment
     */
    public function personEmploymentApi($debtor_account_number, $id, $token)
    {
        list($response) = $this->personEmploymentApiWithHttpInfo($debtor_account_number, $id, $token);
        return $response;
    }

    /**
     * Operation personEmploymentApiWithHttpInfo
     *
     * Retrieves a employment that the person have, from the given id.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  int $id The Id of the wanted employment (EmploymentId) (required)
     * @param  string $token access token (required)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Employment, HTTP status code, HTTP response headers (array of strings)
     */
    public function personEmploymentApiWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '\Membercare\Client\Model\Employment';
        $request = $this->personEmploymentApiRequest($debtor_account_number, $id, $token);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Employment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personEmploymentApiAsync
     *
     * Retrieves a employment that the person have, from the given id.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  int $id The Id of the wanted employment (EmploymentId) (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personEmploymentApiAsync($debtor_account_number, $id, $token)
    {
        return $this->personEmploymentApiAsyncWithHttpInfo($debtor_account_number, $id, $token)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personEmploymentApiAsyncWithHttpInfo
     *
     * Retrieves a employment that the person have, from the given id.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  int $id The Id of the wanted employment (EmploymentId) (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personEmploymentApiAsyncWithHttpInfo($debtor_account_number, $id, $token)
    {
        $returnType = '\Membercare\Client\Model\Employment';
        $request = $this->personEmploymentApiRequest($debtor_account_number, $id, $token);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personEmploymentApi'
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  int $id The Id of the wanted employment (EmploymentId) (required)
     * @param  string $token access token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personEmploymentApiRequest($debtor_account_number, $id, $token)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling personEmploymentApi'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling personEmploymentApi'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personEmploymentApi'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/employments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personEmploymentsApi
     *
     * Retrieves a paged result of employments that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Include historical and future employments? (optional, default to false)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of employments to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\EmploymentPagedResult
     */
    public function personEmploymentsApi($debtor_account_number, $token, $only_valid = 'false', $page = '1', $page_size = '50')
    {
        list($response) = $this->personEmploymentsApiWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size);
        return $response;
    }

    /**
     * Operation personEmploymentsApiWithHttpInfo
     *
     * Retrieves a paged result of employments that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Include historical and future employments? (optional, default to false)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of employments to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\EmploymentPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function personEmploymentsApiWithHttpInfo($debtor_account_number, $token, $only_valid = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\EmploymentPagedResult';
        $request = $this->personEmploymentsApiRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\EmploymentPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personEmploymentsApiAsync
     *
     * Retrieves a paged result of employments that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Include historical and future employments? (optional, default to false)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of employments to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personEmploymentsApiAsync($debtor_account_number, $token, $only_valid = 'false', $page = '1', $page_size = '50')
    {
        return $this->personEmploymentsApiAsyncWithHttpInfo($debtor_account_number, $token, $only_valid, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personEmploymentsApiAsyncWithHttpInfo
     *
     * Retrieves a paged result of employments that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Include historical and future employments? (optional, default to false)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of employments to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personEmploymentsApiAsyncWithHttpInfo($debtor_account_number, $token, $only_valid = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\EmploymentPagedResult';
        $request = $this->personEmploymentsApiRequest($debtor_account_number, $token, $only_valid, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personEmploymentsApi'
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  bool $only_valid Include historical and future employments? (optional, default to false)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of employments to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personEmploymentsApiRequest($debtor_account_number, $token, $only_valid = 'false', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling personEmploymentsApi'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personEmploymentsApi'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/employments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($only_valid !== null) {
            $queryParams['onlyValid'] = ObjectSerializer::toQueryValue($only_valid, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation personMemberEducations
     *
     * Retrieves a paged result of educations that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of educations to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MemberEducationPagedResult
     */
    public function personMemberEducations($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        list($response) = $this->personMemberEducationsWithHttpInfo($debtor_account_number, $token, $page, $page_size);
        return $response;
    }

    /**
     * Operation personMemberEducationsWithHttpInfo
     *
     * Retrieves a paged result of educations that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of educations to display per paged result. (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MemberEducationPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function personMemberEducationsWithHttpInfo($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\MemberEducationPagedResult';
        $request = $this->personMemberEducationsRequest($debtor_account_number, $token, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MemberEducationPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation personMemberEducationsAsync
     *
     * Retrieves a paged result of educations that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of educations to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personMemberEducationsAsync($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        return $this->personMemberEducationsAsyncWithHttpInfo($debtor_account_number, $token, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation personMemberEducationsAsyncWithHttpInfo
     *
     * Retrieves a paged result of educations that the person have.
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of educations to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function personMemberEducationsAsyncWithHttpInfo($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\MemberEducationPagedResult';
        $request = $this->personMemberEducationsRequest($debtor_account_number, $token, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'personMemberEducations'
     *
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  string $token access token (required)
     * @param  int $page Optional, represents the page you wish to see, starting at 1. (optional, default to 1)
     * @param  int $page_size Optional, represents the amount of educations to display per paged result. (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function personMemberEducationsRequest($debtor_account_number, $token, $page = '1', $page_size = '50')
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling personMemberEducations'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling personMemberEducations'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/memberEducations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postAddressesForPerson
     *
     * Takes a list of postaladdress, and inserts it for the given DebtorAccountNumber.  Note that the following values Must be assigned:      - debtorAccountNumber      - list of postaladdress (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\PostalAddress[] $body The list of postal address to be created (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PostalAddress[]
     */
    public function postAddressesForPerson($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postAddressesForPersonWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postAddressesForPersonWithHttpInfo
     *
     * Takes a list of postaladdress, and inserts it for the given DebtorAccountNumber.  Note that the following values Must be assigned:      - debtorAccountNumber      - list of postaladdress (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\PostalAddress[] $body The list of postal address to be created (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PostalAddress[], HTTP status code, HTTP response headers (array of strings)
     */
    public function postAddressesForPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PostalAddress[]';
        $request = $this->postAddressesForPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PostalAddress[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postAddressesForPersonAsync
     *
     * Takes a list of postaladdress, and inserts it for the given DebtorAccountNumber.  Note that the following values Must be assigned:      - debtorAccountNumber      - list of postaladdress (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\PostalAddress[] $body The list of postal address to be created (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAddressesForPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postAddressesForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postAddressesForPersonAsyncWithHttpInfo
     *
     * Takes a list of postaladdress, and inserts it for the given DebtorAccountNumber.  Note that the following values Must be assigned:      - debtorAccountNumber      - list of postaladdress (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\PostalAddress[] $body The list of postal address to be created (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postAddressesForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PostalAddress[]';
        $request = $this->postAddressesForPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postAddressesForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\PostalAddress[] $body The list of postal address to be created (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postAddressesForPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postAddressesForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postAddressesForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/addresses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postContactsForPerson
     *
     * Takes a list of contacts, and inserts it for the given DebtorAccountNumber and EmploymentId (if given).  Note that the following values Must be assigned:      - debtorAccountNumber      - list of contacts (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\Contact[] $body The list of contacts to be created (optional)
     * @param  int $employment_id The Id for the Employment that the list of contacts should be referenced (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Contact[]
     */
    public function postContactsForPerson($token, $debtor_account_number, $body = null, $employment_id = null)
    {
        list($response) = $this->postContactsForPersonWithHttpInfo($token, $debtor_account_number, $body, $employment_id);
        return $response;
    }

    /**
     * Operation postContactsForPersonWithHttpInfo
     *
     * Takes a list of contacts, and inserts it for the given DebtorAccountNumber and EmploymentId (if given).  Note that the following values Must be assigned:      - debtorAccountNumber      - list of contacts (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\Contact[] $body The list of contacts to be created (optional)
     * @param  int $employment_id The Id for the Employment that the list of contacts should be referenced (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Contact[], HTTP status code, HTTP response headers (array of strings)
     */
    public function postContactsForPersonWithHttpInfo($token, $debtor_account_number, $body = null, $employment_id = null)
    {
        $returnType = '\Membercare\Client\Model\Contact[]';
        $request = $this->postContactsForPersonRequest($token, $debtor_account_number, $body, $employment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Contact[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postContactsForPersonAsync
     *
     * Takes a list of contacts, and inserts it for the given DebtorAccountNumber and EmploymentId (if given).  Note that the following values Must be assigned:      - debtorAccountNumber      - list of contacts (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\Contact[] $body The list of contacts to be created (optional)
     * @param  int $employment_id The Id for the Employment that the list of contacts should be referenced (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postContactsForPersonAsync($token, $debtor_account_number, $body = null, $employment_id = null)
    {
        return $this->postContactsForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body, $employment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postContactsForPersonAsyncWithHttpInfo
     *
     * Takes a list of contacts, and inserts it for the given DebtorAccountNumber and EmploymentId (if given).  Note that the following values Must be assigned:      - debtorAccountNumber      - list of contacts (body object)
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\Contact[] $body The list of contacts to be created (optional)
     * @param  int $employment_id The Id for the Employment that the list of contacts should be referenced (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postContactsForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null, $employment_id = null)
    {
        $returnType = '\Membercare\Client\Model\Contact[]';
        $request = $this->postContactsForPersonRequest($token, $debtor_account_number, $body, $employment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postContactsForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\Contact[] $body The list of contacts to be created (optional)
     * @param  int $employment_id The Id for the Employment that the list of contacts should be referenced (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postContactsForPersonRequest($token, $debtor_account_number, $body = null, $employment_id = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postContactsForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postContactsForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/contacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($employment_id !== null) {
            $queryParams['employmentId'] = ObjectSerializer::toQueryValue($employment_id, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postCustomFieldValueForPerson
     *
     * Takes a CustomFieldValue, and inserts it for the given Debtor.  Note that the following values Must be assigned:      - CustomFieldValue.Type.Id      - CustomFieldValue.StartDate      - CustomFieldValue.Value      - Optional, the EndDate can be assigned      - Optional, the Description can be assigned
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\CustomFieldValue $body The actual Value to be inserted (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\CustomFieldValue
     */
    public function postCustomFieldValueForPerson($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postCustomFieldValueForPersonWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postCustomFieldValueForPersonWithHttpInfo
     *
     * Takes a CustomFieldValue, and inserts it for the given Debtor.  Note that the following values Must be assigned:      - CustomFieldValue.Type.Id      - CustomFieldValue.StartDate      - CustomFieldValue.Value      - Optional, the EndDate can be assigned      - Optional, the Description can be assigned
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\CustomFieldValue $body The actual Value to be inserted (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\CustomFieldValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function postCustomFieldValueForPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\CustomFieldValue';
        $request = $this->postCustomFieldValueForPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\CustomFieldValue',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postCustomFieldValueForPersonAsync
     *
     * Takes a CustomFieldValue, and inserts it for the given Debtor.  Note that the following values Must be assigned:      - CustomFieldValue.Type.Id      - CustomFieldValue.StartDate      - CustomFieldValue.Value      - Optional, the EndDate can be assigned      - Optional, the Description can be assigned
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\CustomFieldValue $body The actual Value to be inserted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCustomFieldValueForPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postCustomFieldValueForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postCustomFieldValueForPersonAsyncWithHttpInfo
     *
     * Takes a CustomFieldValue, and inserts it for the given Debtor.  Note that the following values Must be assigned:      - CustomFieldValue.Type.Id      - CustomFieldValue.StartDate      - CustomFieldValue.Value      - Optional, the EndDate can be assigned      - Optional, the Description can be assigned
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\CustomFieldValue $body The actual Value to be inserted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postCustomFieldValueForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\CustomFieldValue';
        $request = $this->postCustomFieldValueForPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postCustomFieldValueForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The Member this value should be present on (required)
     * @param  \Membercare\Client\Model\CustomFieldValue $body The actual Value to be inserted (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postCustomFieldValueForPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postCustomFieldValueForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postCustomFieldValueForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/customFields/values';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postEmploymentForPerson
     *
     * Saves a new employment on the person with the given debtorAccountNumber  - Employment.Company.DebtorAccountNumber is mandatory in order to find the Company  - Employment contacts are also saved
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\Employment $body The employment object to save. (optional)
     * @param  int $create_employment_worklist_template_id create_employment_worklist_template_id (optional)
     * @param  int $end_employment_worklist_template_id end_employment_worklist_template_id (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Employment
     */
    public function postEmploymentForPerson($token, $debtor_account_number, $body = null, $create_employment_worklist_template_id = null, $end_employment_worklist_template_id = null)
    {
        list($response) = $this->postEmploymentForPersonWithHttpInfo($token, $debtor_account_number, $body, $create_employment_worklist_template_id, $end_employment_worklist_template_id);
        return $response;
    }

    /**
     * Operation postEmploymentForPersonWithHttpInfo
     *
     * Saves a new employment on the person with the given debtorAccountNumber  - Employment.Company.DebtorAccountNumber is mandatory in order to find the Company  - Employment contacts are also saved
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\Employment $body The employment object to save. (optional)
     * @param  int $create_employment_worklist_template_id (optional)
     * @param  int $end_employment_worklist_template_id (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Employment, HTTP status code, HTTP response headers (array of strings)
     */
    public function postEmploymentForPersonWithHttpInfo($token, $debtor_account_number, $body = null, $create_employment_worklist_template_id = null, $end_employment_worklist_template_id = null)
    {
        $returnType = '\Membercare\Client\Model\Employment';
        $request = $this->postEmploymentForPersonRequest($token, $debtor_account_number, $body, $create_employment_worklist_template_id, $end_employment_worklist_template_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Employment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postEmploymentForPersonAsync
     *
     * Saves a new employment on the person with the given debtorAccountNumber  - Employment.Company.DebtorAccountNumber is mandatory in order to find the Company  - Employment contacts are also saved
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\Employment $body The employment object to save. (optional)
     * @param  int $create_employment_worklist_template_id (optional)
     * @param  int $end_employment_worklist_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postEmploymentForPersonAsync($token, $debtor_account_number, $body = null, $create_employment_worklist_template_id = null, $end_employment_worklist_template_id = null)
    {
        return $this->postEmploymentForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body, $create_employment_worklist_template_id, $end_employment_worklist_template_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postEmploymentForPersonAsyncWithHttpInfo
     *
     * Saves a new employment on the person with the given debtorAccountNumber  - Employment.Company.DebtorAccountNumber is mandatory in order to find the Company  - Employment contacts are also saved
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\Employment $body The employment object to save. (optional)
     * @param  int $create_employment_worklist_template_id (optional)
     * @param  int $end_employment_worklist_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postEmploymentForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null, $create_employment_worklist_template_id = null, $end_employment_worklist_template_id = null)
    {
        $returnType = '\Membercare\Client\Model\Employment';
        $request = $this->postEmploymentForPersonRequest($token, $debtor_account_number, $body, $create_employment_worklist_template_id, $end_employment_worklist_template_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postEmploymentForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\Employment $body The employment object to save. (optional)
     * @param  int $create_employment_worklist_template_id (optional)
     * @param  int $end_employment_worklist_template_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postEmploymentForPersonRequest($token, $debtor_account_number, $body = null, $create_employment_worklist_template_id = null, $end_employment_worklist_template_id = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postEmploymentForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postEmploymentForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/employments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($create_employment_worklist_template_id !== null) {
            $queryParams['createEmploymentWorklistTemplateId'] = ObjectSerializer::toQueryValue($create_employment_worklist_template_id, 'int64');
        }
        // query params
        if ($end_employment_worklist_template_id !== null) {
            $queryParams['endEmploymentWorklistTemplateId'] = ObjectSerializer::toQueryValue($end_employment_worklist_template_id, 'int64');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postExternalLoginToPerson
     *
     * Saves external login information after successful authentication by the login provider
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\ExternalLogin $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\ExternalLogin
     */
    public function postExternalLoginToPerson($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postExternalLoginToPersonWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postExternalLoginToPersonWithHttpInfo
     *
     * Saves external login information after successful authentication by the login provider
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\ExternalLogin $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\ExternalLogin, HTTP status code, HTTP response headers (array of strings)
     */
    public function postExternalLoginToPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\ExternalLogin';
        $request = $this->postExternalLoginToPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ExternalLogin',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postExternalLoginToPersonAsync
     *
     * Saves external login information after successful authentication by the login provider
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\ExternalLogin $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postExternalLoginToPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postExternalLoginToPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postExternalLoginToPersonAsyncWithHttpInfo
     *
     * Saves external login information after successful authentication by the login provider
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\ExternalLogin $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postExternalLoginToPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\ExternalLogin';
        $request = $this->postExternalLoginToPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postExternalLoginToPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\ExternalLogin $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postExternalLoginToPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postExternalLoginToPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postExternalLoginToPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/externalLogin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postFamilyRelations
     *
     * Creates a list of familyRelations
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\FamilyRelation[] $body Note that the following values Must be assigned:
- FamilyRelation.Parent.DebtorAccountNumber
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\FamilyRelation
     */
    public function postFamilyRelations($token, $body = null)
    {
        list($response) = $this->postFamilyRelationsWithHttpInfo($token, $body);
        return $response;
    }

    /**
     * Operation postFamilyRelationsWithHttpInfo
     *
     * Creates a list of familyRelations
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\FamilyRelation[] $body Note that the following values Must be assigned:
- FamilyRelation.Parent.DebtorAccountNumber
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\FamilyRelation, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFamilyRelationsWithHttpInfo($token, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->postFamilyRelationsRequest($token, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\FamilyRelation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFamilyRelationsAsync
     *
     * Creates a list of familyRelations
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\FamilyRelation[] $body Note that the following values Must be assigned:
- FamilyRelation.Parent.DebtorAccountNumber
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFamilyRelationsAsync($token, $body = null)
    {
        return $this->postFamilyRelationsAsyncWithHttpInfo($token, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFamilyRelationsAsyncWithHttpInfo
     *
     * Creates a list of familyRelations
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\FamilyRelation[] $body Note that the following values Must be assigned:
- FamilyRelation.Parent.DebtorAccountNumber
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFamilyRelationsAsyncWithHttpInfo($token, $body = null)
    {
        $returnType = '\Membercare\Client\Model\FamilyRelation';
        $request = $this->postFamilyRelationsRequest($token, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postFamilyRelations'
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\FamilyRelation[] $body Note that the following values Must be assigned:
- FamilyRelation.Parent.DebtorAccountNumber
- FamilyRelation.Child.DebtorAccountNumber
- FamilyRelation.StartDate
- FamilyRelation.FamilyRelationCategory.CategoryId
- Optional, FamilyRelation.EndDate (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postFamilyRelationsRequest($token, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postFamilyRelations'
            );
        }

        $resourcePath = '/api/v1/persons/families';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postInterestForPerson
     *
     * Saves the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postInterestForPerson($token, $debtor_account_number, $body = null)
    {
        $this->postInterestForPersonWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation postInterestForPersonWithHttpInfo
     *
     * Saves the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postInterestForPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postInterestForPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postInterestForPersonAsync
     *
     * Saves the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInterestForPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postInterestForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postInterestForPersonAsyncWithHttpInfo
     *
     * Saves the interest
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postInterestForPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postInterestForPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postInterestForPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\InterestCategory $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postInterestForPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postInterestForPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postInterestForPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/interests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postMembershipPerson
     *
     * Creates a membership for a person.    MembershipCategory, ApplicationDate, AffiliateDate, ApplicationStatus are mandatory.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the person to add the provided Membership to. (required)
     * @param  \Membercare\Client\Model\MembershipPost $body The Membership to insert (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Membership
     */
    public function postMembershipPerson($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postMembershipPersonWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postMembershipPersonWithHttpInfo
     *
     * Creates a membership for a person.    MembershipCategory, ApplicationDate, AffiliateDate, ApplicationStatus are mandatory.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the person to add the provided Membership to. (required)
     * @param  \Membercare\Client\Model\MembershipPost $body The Membership to insert (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Membership, HTTP status code, HTTP response headers (array of strings)
     */
    public function postMembershipPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Membership';
        $request = $this->postMembershipPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Membership',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postMembershipPersonAsync
     *
     * Creates a membership for a person.    MembershipCategory, ApplicationDate, AffiliateDate, ApplicationStatus are mandatory.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the person to add the provided Membership to. (required)
     * @param  \Membercare\Client\Model\MembershipPost $body The Membership to insert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMembershipPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postMembershipPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postMembershipPersonAsyncWithHttpInfo
     *
     * Creates a membership for a person.    MembershipCategory, ApplicationDate, AffiliateDate, ApplicationStatus are mandatory.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the person to add the provided Membership to. (required)
     * @param  \Membercare\Client\Model\MembershipPost $body The Membership to insert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postMembershipPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Membership';
        $request = $this->postMembershipPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postMembershipPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtorAccountNumber of the person to add the provided Membership to. (required)
     * @param  \Membercare\Client\Model\MembershipPost $body The Membership to insert (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postMembershipPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postMembershipPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postMembershipPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/memberships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonApi
     *
     * Inserts or Updates the provided person.  Addresses and Contact has to be empty. Use routes designed specific to handle insert/update of addresses and contacts.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\Person $body The Person object to create or update person from. (optional)
     * @param  bool $use_automatic_debtor_account_number use_automatic_debtor_account_number (optional, default to true)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function postPersonApi($token, $body = null, $use_automatic_debtor_account_number = 'true')
    {
        list($response) = $this->postPersonApiWithHttpInfo($token, $body, $use_automatic_debtor_account_number);
        return $response;
    }

    /**
     * Operation postPersonApiWithHttpInfo
     *
     * Inserts or Updates the provided person.  Addresses and Contact has to be empty. Use routes designed specific to handle insert/update of addresses and contacts.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\Person $body The Person object to create or update person from. (optional)
     * @param  bool $use_automatic_debtor_account_number (optional, default to true)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonApiWithHttpInfo($token, $body = null, $use_automatic_debtor_account_number = 'true')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->postPersonApiRequest($token, $body, $use_automatic_debtor_account_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonApiAsync
     *
     * Inserts or Updates the provided person.  Addresses and Contact has to be empty. Use routes designed specific to handle insert/update of addresses and contacts.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\Person $body The Person object to create or update person from. (optional)
     * @param  bool $use_automatic_debtor_account_number (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonApiAsync($token, $body = null, $use_automatic_debtor_account_number = 'true')
    {
        return $this->postPersonApiAsyncWithHttpInfo($token, $body, $use_automatic_debtor_account_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonApiAsyncWithHttpInfo
     *
     * Inserts or Updates the provided person.  Addresses and Contact has to be empty. Use routes designed specific to handle insert/update of addresses and contacts.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\Person $body The Person object to create or update person from. (optional)
     * @param  bool $use_automatic_debtor_account_number (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonApiAsyncWithHttpInfo($token, $body = null, $use_automatic_debtor_account_number = 'true')
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->postPersonApiRequest($token, $body, $use_automatic_debtor_account_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonApi'
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\Person $body The Person object to create or update person from. (optional)
     * @param  bool $use_automatic_debtor_account_number (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonApiRequest($token, $body = null, $use_automatic_debtor_account_number = 'true')
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonApi'
            );
        }

        $resourcePath = '/api/v1/persons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($use_automatic_debtor_account_number !== null) {
            $queryParams['useAutomaticDebtorAccountNumber'] = ObjectSerializer::toQueryValue($use_automatic_debtor_account_number, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonConsent
     *
     * Associate Consent with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Consent
     */
    public function postPersonConsent($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonConsentWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonConsentWithHttpInfo
     *
     * Associate Consent with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Consent, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonConsentWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Consent';
        $request = $this->postPersonConsentRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Consent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonConsentAsync
     *
     * Associate Consent with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonConsentAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonConsentAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonConsentAsyncWithHttpInfo
     *
     * Associate Consent with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonConsentAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Consent';
        $request = $this->postPersonConsentRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonConsent'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Consent $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonConsentRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonConsent'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonConsent'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/consent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonDocument
     *
     * Saves a PersonDocument with content in it.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\PersonDocument $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonDocument
     */
    public function postPersonDocument($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonDocumentWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonDocumentWithHttpInfo
     *
     * Saves a PersonDocument with content in it.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\PersonDocument $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonDocumentWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PersonDocument';
        $request = $this->postPersonDocumentRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonDocumentAsync
     *
     * Saves a PersonDocument with content in it.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\PersonDocument $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonDocumentAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonDocumentAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonDocumentAsyncWithHttpInfo
     *
     * Saves a PersonDocument with content in it.
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\PersonDocument $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonDocumentAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PersonDocument';
        $request = $this->postPersonDocumentRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonDocument'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\PersonDocument $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonDocumentRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonDocument'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonDocument'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/document';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonFoerignSystem
     *
     * Associate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  int $id id (required)
     * @param  string $token access token (required)
     * @param  string $external_id external_id (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPersonFoerignSystem($debtor_account_number, $id, $token, $external_id = null)
    {
        $this->postPersonFoerignSystemWithHttpInfo($debtor_account_number, $id, $token, $external_id);
    }

    /**
     * Operation postPersonFoerignSystemWithHttpInfo
     *
     * Associate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     * @param  string $external_id (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonFoerignSystemWithHttpInfo($debtor_account_number, $id, $token, $external_id = null)
    {
        $returnType = '';
        $request = $this->postPersonFoerignSystemRequest($debtor_account_number, $id, $token, $external_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonFoerignSystemAsync
     *
     * Associate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     * @param  string $external_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonFoerignSystemAsync($debtor_account_number, $id, $token, $external_id = null)
    {
        return $this->postPersonFoerignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token, $external_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonFoerignSystemAsyncWithHttpInfo
     *
     * Associate ForeginSystem with a Person
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     * @param  string $external_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonFoerignSystemAsyncWithHttpInfo($debtor_account_number, $id, $token, $external_id = null)
    {
        $returnType = '';
        $request = $this->postPersonFoerignSystemRequest($debtor_account_number, $id, $token, $external_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonFoerignSystem'
     *
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  string $token access token (required)
     * @param  string $external_id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonFoerignSystemRequest($debtor_account_number, $id, $token, $external_id = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonFoerignSystem'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling postPersonFoerignSystem'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonFoerignSystem'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/foreignSystem/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($external_id !== null) {
            $queryParams['externalId'] = ObjectSerializer::toQueryValue($external_id, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonMemberEducation
     *
     * Saves a new MemberEducation on the person with the given debtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\MemberEducation $body The MemberEducation object to save. (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPersonMemberEducation($token, $debtor_account_number, $body = null)
    {
        $this->postPersonMemberEducationWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation postPersonMemberEducationWithHttpInfo
     *
     * Saves a new MemberEducation on the person with the given debtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\MemberEducation $body The MemberEducation object to save. (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonMemberEducationWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postPersonMemberEducationRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonMemberEducationAsync
     *
     * Saves a new MemberEducation on the person with the given debtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\MemberEducation $body The MemberEducation object to save. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonMemberEducationAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonMemberEducationAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonMemberEducationAsyncWithHttpInfo
     *
     * Saves a new MemberEducation on the person with the given debtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\MemberEducation $body The MemberEducation object to save. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonMemberEducationAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postPersonMemberEducationRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonMemberEducation'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The person&#x27;s DebtorAccountNumber (required)
     * @param  \Membercare\Client\Model\MemberEducation $body The MemberEducation object to save. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonMemberEducationRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonMemberEducation'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonMemberEducation'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/memberEducations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonMembercareUser
     *
     * Creates a new MembercareUser for the person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUser $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MembercareUser
     */
    public function postPersonMembercareUser($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonMembercareUserWithHttpInfo
     *
     * Creates a new MembercareUser for the person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUser $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MembercareUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->postPersonMembercareUserRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MembercareUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonMembercareUserAsync
     *
     * Creates a new MembercareUser for the person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUser $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonMembercareUserAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonMembercareUserAsyncWithHttpInfo
     *
     * Creates a new MembercareUser for the person with the given DebtorAccountNumber
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUser $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->postPersonMembercareUserRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonMembercareUser'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\MembercareUser $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonMembercareUserRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonMembercareUser'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonMembercareUser'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/membercareUsers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonProfilePicture
     *
     * Uploads a profile picture to a person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonProfilePicturePost $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postPersonProfilePicture($token, $debtor_account_number, $body = null)
    {
        $this->postPersonProfilePictureWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation postPersonProfilePictureWithHttpInfo
     *
     * Uploads a profile picture to a person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonProfilePicturePost $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonProfilePictureWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postPersonProfilePictureRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonProfilePictureAsync
     *
     * Uploads a profile picture to a person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonProfilePicturePost $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonProfilePictureAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonProfilePictureAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonProfilePictureAsyncWithHttpInfo
     *
     * Uploads a profile picture to a person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonProfilePicturePost $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonProfilePictureAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postPersonProfilePictureRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonProfilePicture'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonProfilePicturePost $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonProfilePictureRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonProfilePicture'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonProfilePicture'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/profilePicture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonStartEnd
     *
     * Update the start and end dates of the provided person
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonStartEnd $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Person
     */
    public function postPersonStartEnd($token, $body = null)
    {
        list($response) = $this->postPersonStartEndWithHttpInfo($token, $body);
        return $response;
    }

    /**
     * Operation postPersonStartEndWithHttpInfo
     *
     * Update the start and end dates of the provided person
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonStartEnd $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Person, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonStartEndWithHttpInfo($token, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->postPersonStartEndRequest($token, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Person',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonStartEndAsync
     *
     * Update the start and end dates of the provided person
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonStartEnd $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonStartEndAsync($token, $body = null)
    {
        return $this->postPersonStartEndAsyncWithHttpInfo($token, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonStartEndAsyncWithHttpInfo
     *
     * Update the start and end dates of the provided person
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonStartEnd $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonStartEndAsyncWithHttpInfo($token, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Person';
        $request = $this->postPersonStartEndRequest($token, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonStartEnd'
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonStartEnd $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonStartEndRequest($token, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonStartEnd'
            );
        }

        $resourcePath = '/api/v1/persons';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonSubscriptionPurchase
     *
     * Creates, invoice and set payment for the provided list of subscription definitions.  Discounts based on membership category are not supported in this webservice
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtor account number of the person who is buying the subscription(s) (required)
     * @param  \Membercare\Client\Model\SubscriptionDefinitionPurchase $body A list of subscription definitions to purchase and a payment (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Subscription[]
     */
    public function postPersonSubscriptionPurchase($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonSubscriptionPurchaseWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonSubscriptionPurchaseWithHttpInfo
     *
     * Creates, invoice and set payment for the provided list of subscription definitions.  Discounts based on membership category are not supported in this webservice
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtor account number of the person who is buying the subscription(s) (required)
     * @param  \Membercare\Client\Model\SubscriptionDefinitionPurchase $body A list of subscription definitions to purchase and a payment (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Subscription[], HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonSubscriptionPurchaseWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Subscription[]';
        $request = $this->postPersonSubscriptionPurchaseRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Subscription[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonSubscriptionPurchaseAsync
     *
     * Creates, invoice and set payment for the provided list of subscription definitions.  Discounts based on membership category are not supported in this webservice
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtor account number of the person who is buying the subscription(s) (required)
     * @param  \Membercare\Client\Model\SubscriptionDefinitionPurchase $body A list of subscription definitions to purchase and a payment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonSubscriptionPurchaseAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonSubscriptionPurchaseAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonSubscriptionPurchaseAsyncWithHttpInfo
     *
     * Creates, invoice and set payment for the provided list of subscription definitions.  Discounts based on membership category are not supported in this webservice
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtor account number of the person who is buying the subscription(s) (required)
     * @param  \Membercare\Client\Model\SubscriptionDefinitionPurchase $body A list of subscription definitions to purchase and a payment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonSubscriptionPurchaseAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Subscription[]';
        $request = $this->postPersonSubscriptionPurchaseRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonSubscriptionPurchase'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number The debtor account number of the person who is buying the subscription(s) (required)
     * @param  \Membercare\Client\Model\SubscriptionDefinitionPurchase $body A list of subscription definitions to purchase and a payment (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonSubscriptionPurchaseRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonSubscriptionPurchase'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonSubscriptionPurchase'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/subscriptions/purchase';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonTerms
     *
     * Associate Terms with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\Terms $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\Terms
     */
    public function postPersonTerms($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonTermsWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonTermsWithHttpInfo
     *
     * Associate Terms with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Terms $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\Terms, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonTermsWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Terms';
        $request = $this->postPersonTermsRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\Terms',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonTermsAsync
     *
     * Associate Terms with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Terms $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonTermsAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonTermsAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonTermsAsyncWithHttpInfo
     *
     * Associate Terms with a Person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Terms $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonTermsAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\Terms';
        $request = $this->postPersonTermsRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonTerms'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Terms $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonTermsRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonTerms'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonTerms'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/terms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postPersonWorklistItem
     *
     * Will insert a worklist item with regards to the person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonWorkListItem $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonWorkListItem
     */
    public function postPersonWorklistItem($token, $debtor_account_number, $body = null)
    {
        list($response) = $this->postPersonWorklistItemWithHttpInfo($token, $debtor_account_number, $body);
        return $response;
    }

    /**
     * Operation postPersonWorklistItemWithHttpInfo
     *
     * Will insert a worklist item with regards to the person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonWorkListItem $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonWorkListItem, HTTP status code, HTTP response headers (array of strings)
     */
    public function postPersonWorklistItemWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PersonWorkListItem';
        $request = $this->postPersonWorklistItemRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonWorkListItem',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postPersonWorklistItemAsync
     *
     * Will insert a worklist item with regards to the person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonWorkListItem $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonWorklistItemAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postPersonWorklistItemAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postPersonWorklistItemAsyncWithHttpInfo
     *
     * Will insert a worklist item with regards to the person
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonWorkListItem $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postPersonWorklistItemAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '\Membercare\Client\Model\PersonWorkListItem';
        $request = $this->postPersonWorklistItemRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postPersonWorklistItem'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\PersonWorkListItem $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postPersonWorklistItemRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postPersonWorklistItem'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postPersonWorklistItem'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/worklistItem';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSubscriptionPerson
     *
     * The Subscriber property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Recipient property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Payer property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  \Membercare\Client\Model\Subscription $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function postSubscriptionPerson($token, $debtor_account_number, $body = null)
    {
        $this->postSubscriptionPersonWithHttpInfo($token, $debtor_account_number, $body);
    }

    /**
     * Operation postSubscriptionPersonWithHttpInfo
     *
     * The Subscriber property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Recipient property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Payer property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Subscription $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSubscriptionPersonWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postSubscriptionPersonRequest($token, $debtor_account_number, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSubscriptionPersonAsync
     *
     * The Subscriber property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Recipient property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Payer property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Subscription $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSubscriptionPersonAsync($token, $debtor_account_number, $body = null)
    {
        return $this->postSubscriptionPersonAsyncWithHttpInfo($token, $debtor_account_number, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSubscriptionPersonAsyncWithHttpInfo
     *
     * The Subscriber property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Recipient property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons  The Payer property on Subscription will need to have a property telling which type the member is eg. \"$type\": \"Membercare.REST.Models.v1.Person.Person, Membercare.REST.Models\" for persons
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Subscription $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSubscriptionPersonAsyncWithHttpInfo($token, $debtor_account_number, $body = null)
    {
        $returnType = '';
        $request = $this->postSubscriptionPersonRequest($token, $debtor_account_number, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSubscriptionPerson'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  \Membercare\Client\Model\Subscription $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postSubscriptionPersonRequest($token, $debtor_account_number, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling postSubscriptionPerson'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling postSubscriptionPerson'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/subscriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPassword
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function putPassword($debtor_account_number, $token, $password = null)
    {
        $this->putPasswordWithHttpInfo($debtor_account_number, $token, $password);
    }

    /**
     * Operation putPasswordWithHttpInfo
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPasswordWithHttpInfo($debtor_account_number, $token, $password = null)
    {
        $returnType = '';
        $request = $this->putPasswordRequest($debtor_account_number, $token, $password);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPasswordAsync
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPasswordAsync($debtor_account_number, $token, $password = null)
    {
        return $this->putPasswordAsyncWithHttpInfo($debtor_account_number, $token, $password)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPasswordAsyncWithHttpInfo
     *
     * Will set the users password to the provided string
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPasswordAsyncWithHttpInfo($debtor_account_number, $token, $password = null)
    {
        $returnType = '';
        $request = $this->putPasswordRequest($debtor_account_number, $token, $password);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPassword'
     *
     * @param  string $debtor_account_number (required)
     * @param  string $token access token (required)
     * @param  string $password (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPasswordRequest($debtor_account_number, $token, $password = null)
    {
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling putPassword'
            );
        }
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling putPassword'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/password';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($password !== null) {
            $queryParams['password'] = ObjectSerializer::toQueryValue($password, null);
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPersonMembercareUser
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber  Roles and DataRoles are not affected
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number debtor_account_number (required)
     * @param  int $id id (required)
     * @param  \Membercare\Client\Model\MembercareUserPut $body body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\MembercareUser
     */
    public function putPersonMembercareUser($token, $debtor_account_number, $id, $body = null)
    {
        list($response) = $this->putPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $id, $body);
        return $response;
    }

    /**
     * Operation putPersonMembercareUserWithHttpInfo
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber  Roles and DataRoles are not affected
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  \Membercare\Client\Model\MembercareUserPut $body (optional)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\MembercareUser, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPersonMembercareUserWithHttpInfo($token, $debtor_account_number, $id, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->putPersonMembercareUserRequest($token, $debtor_account_number, $id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\MembercareUser',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPersonMembercareUserAsync
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber  Roles and DataRoles are not affected
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  \Membercare\Client\Model\MembercareUserPut $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPersonMembercareUserAsync($token, $debtor_account_number, $id, $body = null)
    {
        return $this->putPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPersonMembercareUserAsyncWithHttpInfo
     *
     * Updates a specific MembercareUser for a person with the given DebtorAccountNumber  Roles and DataRoles are not affected
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  \Membercare\Client\Model\MembercareUserPut $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPersonMembercareUserAsyncWithHttpInfo($token, $debtor_account_number, $id, $body = null)
    {
        $returnType = '\Membercare\Client\Model\MembercareUser';
        $request = $this->putPersonMembercareUserRequest($token, $debtor_account_number, $id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPersonMembercareUser'
     *
     * @param  string $token access token (required)
     * @param  string $debtor_account_number (required)
     * @param  int $id (required)
     * @param  \Membercare\Client\Model\MembercareUserPut $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putPersonMembercareUserRequest($token, $debtor_account_number, $id, $body = null)
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling putPersonMembercareUser'
            );
        }
        // verify the required parameter 'debtor_account_number' is set
        if ($debtor_account_number === null || (is_array($debtor_account_number) && count($debtor_account_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $debtor_account_number when calling putPersonMembercareUser'
            );
        }
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putPersonMembercareUser'
            );
        }

        $resourcePath = '/api/v1/persons/{debtorAccountNumber}/membercareUsers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }

        // path params
        if ($debtor_account_number !== null) {
            $resourcePath = str_replace(
                '{' . 'debtorAccountNumber' . '}',
                ObjectSerializer::toPathValue($debtor_account_number),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchPerson
     *
     * Get a paged result of persons that match the search string.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonSearch $body Search string container object (optional)
     * @param  bool $include_memberships include_memberships (optional, default to false)
     * @param  bool $include_board_memberships include_board_memberships (optional, default to false)
     * @param  bool $include_custom_fields include_custom_fields (optional, default to false)
     * @param  bool $include_interests include_interests (optional, default to false)
     * @param  int $page page (optional, default to 1)
     * @param  int $page_size page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Membercare\Client\Model\PersonPagedResult
     */
    public function searchPerson($token, $body = null, $include_memberships = 'false', $include_board_memberships = 'false', $include_custom_fields = 'false', $include_interests = 'false', $page = '1', $page_size = '50')
    {
        list($response) = $this->searchPersonWithHttpInfo($token, $body, $include_memberships, $include_board_memberships, $include_custom_fields, $include_interests, $page, $page_size);
        return $response;
    }

    /**
     * Operation searchPersonWithHttpInfo
     *
     * Get a paged result of persons that match the search string.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonSearch $body Search string container object (optional)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \Membercare\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Membercare\Client\Model\PersonPagedResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchPersonWithHttpInfo($token, $body = null, $include_memberships = 'false', $include_board_memberships = 'false', $include_custom_fields = 'false', $include_interests = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->searchPersonRequest($token, $body, $include_memberships, $include_board_memberships, $include_custom_fields, $include_interests, $page, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\PersonPagedResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Membercare\Client\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchPersonAsync
     *
     * Get a paged result of persons that match the search string.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonSearch $body Search string container object (optional)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPersonAsync($token, $body = null, $include_memberships = 'false', $include_board_memberships = 'false', $include_custom_fields = 'false', $include_interests = 'false', $page = '1', $page_size = '50')
    {
        return $this->searchPersonAsyncWithHttpInfo($token, $body, $include_memberships, $include_board_memberships, $include_custom_fields, $include_interests, $page, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchPersonAsyncWithHttpInfo
     *
     * Get a paged result of persons that match the search string.
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonSearch $body Search string container object (optional)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchPersonAsyncWithHttpInfo($token, $body = null, $include_memberships = 'false', $include_board_memberships = 'false', $include_custom_fields = 'false', $include_interests = 'false', $page = '1', $page_size = '50')
    {
        $returnType = '\Membercare\Client\Model\PersonPagedResult';
        $request = $this->searchPersonRequest($token, $body, $include_memberships, $include_board_memberships, $include_custom_fields, $include_interests, $page, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchPerson'
     *
     * @param  string $token access token (required)
     * @param  \Membercare\Client\Model\PersonSearch $body Search string container object (optional)
     * @param  bool $include_memberships (optional, default to false)
     * @param  bool $include_board_memberships (optional, default to false)
     * @param  bool $include_custom_fields (optional, default to false)
     * @param  bool $include_interests (optional, default to false)
     * @param  int $page (optional, default to 1)
     * @param  int $page_size (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchPersonRequest($token, $body = null, $include_memberships = 'false', $include_board_memberships = 'false', $include_custom_fields = 'false', $include_interests = 'false', $page = '1', $page_size = '50')
    {
        // verify the required parameter 'token' is set
        if ($token === null || (is_array($token) && count($token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $token when calling searchPerson'
            );
        }

        $resourcePath = '/api/v1/persons/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_memberships !== null) {
            $queryParams['includeMemberships'] = ObjectSerializer::toQueryValue($include_memberships, null);
        }
        // query params
        if ($include_board_memberships !== null) {
            $queryParams['includeBoardMemberships'] = ObjectSerializer::toQueryValue($include_board_memberships, null);
        }
        // query params
        if ($include_custom_fields !== null) {
            $queryParams['includeCustomFields'] = ObjectSerializer::toQueryValue($include_custom_fields, null);
        }
        // query params
        if ($include_interests !== null) {
            $queryParams['includeInterests'] = ObjectSerializer::toQueryValue($include_interests, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size, 'int32');
        }
        // header params
        if ($token !== null) {
            $headerParams['token'] = ObjectSerializer::toHeaderValue($token);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
